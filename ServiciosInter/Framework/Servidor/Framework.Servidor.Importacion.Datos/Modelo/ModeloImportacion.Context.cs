//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Common;
using System.Data.EntityClient;
using System.Data.Metadata.Edm;
using System.Data.Objects.DataClasses;
using System.Data.Objects;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Framework.Servidor.Importacion.Datos.Modelo
{
    /// <summary>
    /// The interface for the specialised object context. This contains all of
    /// the <code>ObjectSet</code> properties that are implemented in both the
    /// functional context class and the mock context class.
    /// </summary>
    public interface IImportacionEntities: IDisposable
    {
        ObjectSet<PlantillaImportacion_PAR> PlantillaImportacion_PAR { get; }
    }
    /// <summary>
       /// Extension methods that make it easy to add auditing functionality to an Entity Framework ObjectContext
       /// </summary>
       public static class AuditExtensions
       {
          /// <summary>
          /// Adds Auditing to an ObjectContext for the specified <paramref name="fromType"/>.
          /// </summary>
          /// <typeparam name="fromType">The source entity type (including derivatives) to audit changes to.</typeparam>
          /// <typeparam name="toType">The target entity type that audit records will be stored in.</typeparam>
          /// <param name="context">The ObjectContext for which Auditing should be enabled.</param>
          /// <param name="mapping">A lambda expression that maps the changed <paramref name="fromType"/> entity to a <paramref name="toType"/> audit record.</param>
          /// <param name="addToContext">A lambda expression that adds the audit entity to an entity collection.</param>
          public static void Audit<fromType, toType>(
              this ObjectContext context,
              Func<IDataRecord, EntityState, toType> mapping,
              Action<toType> addToContext)
          {
             context.SavingChanges +=
                 new EventHandler((o, e) =>
                     CreateAuditRecord<fromType, toType>(context, mapping, addToContext));
          }
    
          /// <summary>
          /// Helper function that is called during ObjectContext.SavingChanges, and is responsible for managing the
          /// process of mapping all changed entities to an audit entity, and adding them to an entity collection.
          /// </summary>
          /// <remarks>
          /// Note that at present this function will be called once for every entity type that is being audited. If
          /// you don't like this it should be easy to optimize it.
          /// </remarks>
          /// <typeparam name="fromType">The source entity type (including derivatives) to audit changes to.</typeparam>
          /// <typeparam name="toType">The target entity type that audit records will be stored in.</typeparam>
          /// <param name="context">The ObjectContext for which Auditing should be enabled.</param>
          /// <param name="mapping">A lambda expression that maps the changed <paramref name="fromType"/> entity to a <paramref name="toType"/> audit record.</param>
          /// <param name="addToContext">A lambda expression that adds the audit entity to an entity collection.</param>
          private static void CreateAuditRecord<fromType, toType>(
              ObjectContext context,
              Func<IDataRecord, EntityState, toType> mapping,
              Action<toType> addToContext)
          {
             context.DetectChanges();
             // get a list of changes to audit
             IEnumerable<ObjectStateEntry> entities =
                 from e in context.ObjectStateManager.GetObjectStateEntries(
                     EntityState.Modified | EntityState.Deleted)
                 where
                     e.IsRelationship == false &&
                     typeof(fromType).IsAssignableFrom(e.Entity.GetType())
                 select e;
    
             foreach (ObjectStateEntry item in entities)
             {
                // map the changed item to an audit record entry
                toType auditRecord = mapping(item.OriginalValues, item.State);
                // and add it to the object context so that it is persisted for us
                addToContext(auditRecord);
             }
          }
    
          /// <summary>
          /// Retrieves a fields value from an IDataRecord (including a DbDataRecord) in a strongly typed,
          /// compile-time checked fashion. This overload assumes the IDataRecord represents an EntityObject
          /// for which a property's value should be retrieved.
          /// </summary>
          /// <typeparam name="E">The Entity type the IDataRecord represents</typeparam>
          /// <typeparam name="T">The data type of the field</typeparam>
          /// <param name="record">The IDataRecord that contains the data</param>
          /// <param name="propertySelector">An expression that identifies the entity member to retrieve</param>
          /// <returns>The field's value.</returns>
          /// <example>
          /// <code>
          /// IDataRecord record = GetRecord();
          /// string name = record.Field&lt;Person, string>(person => person.Name);
          /// int age = record.Field&lt;Person, int>(person => person.Age);
          /// DateTime createdDate = record.Field&lt;Person, DateTime>(person => person.CreatedDate);
          /// </code>
          /// </example>
          public static T Field<E, T>(this IDataRecord record, System.Linq.Expressions.Expression<Func<E, T>> propertySelector)
          {
             System.Linq.Expressions.MemberExpression memberExpression = propertySelector.Body as System.Linq.Expressions.MemberExpression;
             System.Reflection.MemberInfo propertyInfo = memberExpression.Member;
    
             int fieldIndex = record.GetOrdinal(propertyInfo.Name);
             return Field<T>(record, fieldIndex);
          }
    
          /// <summary>
          /// Retrieves a fields value from an IDataRecord in a strongly typed fashion.
          /// </summary>
          /// <remarks>
          /// This code is based on similar functionality in the EFExtensions project; see
          /// http://code.msdn.microsoft.com/EFExtensions
          /// </remarks>
          /// <typeparam name="T">The data type of the field.</typeparam>
          /// <param name="record">The IDataRecord that contains the data</param>
          /// <param name="ordinal">The field's index in the IDataRecord</param>
          /// <returns>The field's value.</returns>
          public static T Field<T>(this IDataRecord record, int ordinal)
          {
             object value = record.IsDBNull(ordinal) ? null : record.GetValue(ordinal);
             return (T)value;
          }
       }
    
    	/// <summary>
       /// Extensión para ordenamiento por nombre del campo
       /// </summary>
       public static class OrderExtension
       {
    		/// <sumary>
    		/// Ordena usando una expresión de ordenamiento, por ejemplo:
    		///		iqueryable.OrdenarUsandoExpresion("Employee.LastName, Freight DESC")
    		/// </sumary>
          public static IOrderedQueryable<TEntity> OrdenarUsandoExpresion<TEntity>(this IQueryable<TEntity> source, string sortExpression) where TEntity : class
          {
                 String[] orderFields = sortExpression.Split(',');
                 IOrderedQueryable<TEntity> result = null;
                  bool sortDescending=false;
                  if (sortExpression.Contains(" DESC"))
                  {
                      sortDescending = true;
                  }
                 for (int currentFieldIndex = 0; currentFieldIndex < orderFields.Length; currentFieldIndex++)
                 {
                    String[] expressionPart = orderFields[currentFieldIndex].Trim().Split(' ');
                    String sortField = expressionPart[0];
                    //Boolean sortDescending = (expressionPart.Length == 2) && (expressionPart[1].Equals("DESC", StringComparison.OrdinalIgnoreCase));
                    if (sortDescending)
                    {
                       result = currentFieldIndex == 0 ? source.OrdenarPorDescendente(sortField) : result.EntoncesPorDescendente(sortField);
                    }
                    else
                    {
                       result = currentFieldIndex == 0 ? source.OrdenarPor(sortField) : result.EntoncesPor(sortField);
                    }
                 }
                 return result;
          }
    
          public static IOrderedQueryable<TEntity> OrdenarPor<TEntity>(this IQueryable<TEntity> source, string fieldName) where TEntity : class
          {
             MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "OrderBy", fieldName);
             return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
          }
    
          public static IOrderedQueryable<TEntity> OrdenarPorDescendente<TEntity>(this IQueryable<TEntity> source, string fieldName) where TEntity : class
          {
             MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "OrderByDescending", fieldName);
             return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
          }
    
          public static IOrderedQueryable<TEntity> EntoncesPor<TEntity>(this IOrderedQueryable<TEntity> source, string fieldName) where TEntity : class
          {
             MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "ThenBy", fieldName);
             return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
          }
    
          public static IOrderedQueryable<TEntity> EntoncesPorDescendente<TEntity>(this IOrderedQueryable<TEntity> source, string fieldName) where TEntity : class
          {
             MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "ThenByDescending", fieldName);
             return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
          }
    
          private static MethodCallExpression GenerateMethodCall<TEntity>(IQueryable<TEntity> source, string methodName, String fieldName) where TEntity : class
          {
             Type type = typeof(TEntity);
             Type selectorResultType;
             LambdaExpression selector = GenerateSelector<TEntity>(fieldName, out selectorResultType);
             MethodCallExpression resultExp = Expression.Call(typeof(Queryable), methodName,
                             new Type[] { type, selectorResultType },
                             source.Expression, Expression.Quote(selector));
             return resultExp;
          }
    
          private static LambdaExpression GenerateSelector<TEntity>(String propertyName, out Type resultType) where TEntity : class
          {
             // Create a parameter to pass into the Lambda expression (Entity => Entity.OrderByField).
             var parameter = Expression.Parameter(typeof(TEntity), "Entity");
             //  create the selector part, but support child properties
             PropertyInfo property;
             Expression propertyAccess;
             if (propertyName.Contains('.'))
             {
                // support to be sorted on child fields.
                String[] childProperties = propertyName.Split('.');
                property = typeof(TEntity).GetProperty(childProperties[0], BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
                propertyAccess = Expression.MakeMemberAccess(parameter, property);
                for (int i = 1; i < childProperties.Length; i++)
                {
                   property = property.PropertyType.GetProperty(childProperties[i], BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
                   propertyAccess = Expression.MakeMemberAccess(propertyAccess, property);
                }
             }
             else
             {
                property = typeof(TEntity).GetProperty(propertyName, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
                propertyAccess = Expression.MakeMemberAccess(parameter, property);
             }
             resultType = property.PropertyType;
             // Create the order by expression.
             return Expression.Lambda(propertyAccess, parameter);
          }
       }
    
    public partial class ImportacionEntities : ObjectContext
    {
        public const string ConnectionString = "name=ImportacionEntities";
        public const string ContainerName = "ImportacionEntities";
    
        #region Constructors
    
        public ImportacionEntities()
            : base(ConnectionString, ContainerName)
        {
            Initialize();
        }
    
        public ImportacionEntities(string connectionString)
            : base(connectionString, ContainerName)
        {
            Initialize(); 
        }
    
        public ImportacionEntities(EntityConnection connection)
            : base(connection, ContainerName)
        {
            Initialize();
        }
    
        private void Initialize()
        {
            // Creating proxies requires the use of the ProxyDataContractResolver and
            // may allow lazy loading which can expand the loaded graph during serialization.
            ContextOptions.ProxyCreationEnabled = false;
            ObjectMaterialized += new ObjectMaterializedEventHandler(HandleObjectMaterialized);
        }
    
        private void HandleObjectMaterialized(object sender, ObjectMaterializedEventArgs e)
        {
            var entity = e.Entity as IObjectWithChangeTracker;
            if (entity != null)
            {
                bool changeTrackingEnabled = entity.ChangeTracker.ChangeTrackingEnabled;
                try
                {
                    entity.MarkAsUnchanged();
                }
                finally
                {
                    entity.ChangeTracker.ChangeTrackingEnabled = changeTrackingEnabled;
                }
                this.StoreReferenceKeyValues(entity);
            }
        }
    
        #endregion
        #region Filtrado
    
    	public Func<TLinqEntity, bool> ObtenerExpresionFiltrado<TLinqEntity>(IDictionary<string, string> filtros)
        {       
            List<ParameterExpression> paramList = new List<ParameterExpression>();
            foreach (KeyValuePair<string,string> filtro in filtros)
            {
                paramList.Add(Expression.Parameter(typeof(TLinqEntity), filtro.Key));
            }
    
            List<LambdaExpression> lexList = new List<LambdaExpression>();
            for (int i = 0; i < filtros.Count; i++)
            {
                if (i == 0)
                {
                    Expression bodyInner = Expression.Equal(
                                        Expression.Property(
                                            paramList[i],filtros.ElementAt(i).Key),
                                            Expression.Constant(filtros.ElementAt(i).Value));
                    lexList.Add(Expression.Lambda(bodyInner, paramList[i]));
                }
                else
                {
                    Expression bodyOuter = Expression.AndAlso(
                                        Expression.Equal(
                                        Expression.Property(
                                        paramList[i], filtros.ElementAt(i).Key),
                                        Expression.Constant(filtros.ElementAt(i).Value)),
                                        Expression.Invoke(lexList[i - 1], paramList[i]));
                    lexList.Add(Expression.Lambda(bodyOuter, paramList[i]));
                }
            }
    
            if (lexList.Count == 0)
            {
                //ParameterExpression param = Expression.Parameter(typeof(int), "x");
                //BinaryExpression expr= Expression.Equal(param, param);
                Func<TLinqEntity, bool> lambda = x => 1 == 1;
                return lambda;
            }
            else
                return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]).Compile();
        }
    
    	    public Func<TLinqEntity, bool> ObtenerExpresionEquals<TLinqEntity>(IDictionary<string, string> filtros)
        {
          List<ParameterExpression> paramList = new List<ParameterExpression>();
          foreach (KeyValuePair<string, string> filtro in filtros)
          {
            paramList.Add(Expression.Parameter(typeof(TLinqEntity), filtro.Key));
          }
    
          List<LambdaExpression> lexList = new List<LambdaExpression>();
          for (int i = 0; i < filtros.Count; i++)
          {
            bool valido = false;
            PropertyInfo prop = typeof(TLinqEntity).GetProperty(filtros.ElementAt(i).Key);
            Type proptype = prop.PropertyType;
    
            Expression callExpr = Expression.MakeMemberAccess(paramList[i], prop);
            Expression valueExpr = Expression.Constant(filtros.ElementAt(i).Value.ToLower());
            Expression body = null;
    
            if (proptype == typeof(string))
            {
              var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));          
              body = Expression.Call(toLower, typeof(string).GetMethod("Equals", new Type[] { typeof(string) }), valueExpr);
              valido = true;
            }
    
            else if (proptype == typeof(int) || proptype == typeof(Nullable) ||
                    proptype == typeof(long) || proptype == typeof(Nullable) ||
                    proptype == typeof(short) || proptype == typeof(Nullable))
            {
              // Check if input data type matches
              object num = null;
              long temp;
              if (long.TryParse(filtros.ElementAt(i).Value, out temp))
              {
                num = temp;
                valueExpr = Expression.Constant(num, proptype);
                body = Expression.Equal(callExpr, valueExpr);
                valido = true;
              }
            }
            else if (proptype == typeof(DateTime) || proptype == typeof(Nullable))
            {
              DateTime date;
              if (DateTime.TryParse(filtros.ElementAt(i).Value, out date))
              {
                valueExpr = Expression.Constant(date, proptype);
                Expression valueExpr2 = Expression.Constant(date.AddHours(24), proptype);
                Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
                Expression body1 = Expression.LessThan(callExpr, valueExpr2);
                body = Expression.AndAlso(bodyBetween, body1);
                valido = true;
              }
            }
            else if (proptype == typeof(bool) || proptype == typeof(Nullable))
            {
              bool val;
              if (bool.TryParse(filtros.ElementAt(i).Value, out val))
              {
                valueExpr = Expression.Constant(val, proptype);
                body = Expression.Equal(callExpr, valueExpr);
                valido = true;
              }
            }
    
            if (valido)
            {
              if (lexList.Count == 0)
              {
                lexList.Add(Expression.Lambda(body, paramList[i]));
              }
              else
              {
                Expression bodyOuter = Expression.AndAlso(
                                    body,
                                    Expression.Invoke(lexList[i - 1], paramList[i]));
                lexList.Add(Expression.Lambda(bodyOuter, paramList[i]));
              }
            }
          }
    
          if (lexList.Count == 0)
          {
            Func<TLinqEntity, bool> lambda = x => 1 == 1;
            return lambda;
          }
          else
            return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]).Compile();
        }
    
        public Func<TLinqEntity, bool> ObtenerExpresionContains<TLinqEntity>(IDictionary<string, string> filtros)
        {
          List<ParameterExpression> paramList = new List<ParameterExpression>();
          foreach (KeyValuePair<string, string> filtro in filtros)
          {
            paramList.Add(Expression.Parameter(typeof(TLinqEntity), filtro.Key));
          }
    
          List<LambdaExpression> lexList = new List<LambdaExpression>();
          for (int i = 0; i < filtros.Count; i++)
          {
            bool valido = false;
            PropertyInfo prop = typeof(TLinqEntity).GetProperty(filtros.ElementAt(i).Key);
            Type proptype = prop.PropertyType;
    
            Expression callExpr = Expression.MakeMemberAccess(paramList[i], prop);
            Expression valueExpr = Expression.Constant(filtros.ElementAt(i).Value.ToLower());
            Expression body = null;
    
            if (proptype == typeof(string))
            {
              var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
              body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
              //body = Expression.Call(toLower, typeof(string).GetMethod("Equals", new Type[] { typeof(string) }), valueExpr);
              valido = true;
            }
    
            else if (proptype == typeof(int) || proptype == typeof(Nullable) ||
                    proptype == typeof(long) || proptype == typeof(Nullable) ||
                    proptype == typeof(short) || proptype == typeof(Nullable))
            {
              // Check if input data type matches
              object num = null;
              long temp;
              if (long.TryParse(filtros.ElementAt(i).Value, out temp))
              {
                num = temp;
                valueExpr = Expression.Constant(num, proptype);
                body = Expression.Equal(callExpr, valueExpr);
                valido = true;
              }
            }
            else if (proptype == typeof(DateTime) || proptype == typeof(Nullable))
            {
              DateTime date;
              if (DateTime.TryParse(filtros.ElementAt(i).Value, out date))
              {
                valueExpr = Expression.Constant(date, proptype);
                Expression valueExpr2 = Expression.Constant(date.AddHours(24), proptype);
                Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
                Expression body1 = Expression.LessThan(callExpr, valueExpr2);
                body = Expression.AndAlso(bodyBetween, body1);
                valido = true;
              }
            }
            else if (proptype == typeof(bool) || proptype == typeof(Nullable))
            {
              bool val;
              if (bool.TryParse(filtros.ElementAt(i).Value, out val))
              {
                valueExpr = Expression.Constant(val, proptype);
                body = Expression.Equal(callExpr, valueExpr);
                valido = true;
              }
            }
    
            if (valido)
            {
              if (lexList.Count == 0)
              {
                lexList.Add(Expression.Lambda(body, paramList[i]));
              }
              else
              {
                Expression bodyOuter = Expression.AndAlso(
                                    body,
                                    Expression.Invoke(lexList[i - 1], paramList[i]));
                lexList.Add(Expression.Lambda(bodyOuter, paramList[i]));
              }
            }
          }
    
          if (lexList.Count == 0)
          {
            Func<TLinqEntity, bool> lambda = x => 1 == 1;
            return lambda;
          }
          else
            return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]).Compile();
        }

        #endregion
            #region Consultas
    	   /// <summary>
    		/// Retorna la lista de PlantillaImportacion_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<PlantillaImportacion_PAR> ConsultarContainsPlantillaImportacion_PAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Func<PlantillaImportacion_PAR, bool> expresionFiltrado = ObtenerExpresionContains<PlantillaImportacion_PAR>(filtro);
    				return ConsultarPlantillaImportacion_PAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		 /// <summary>
    		/// Retorna la lista de PlantillaImportacion_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<PlantillaImportacion_PAR> ConsultarEqualsPlantillaImportacion_PAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Func<PlantillaImportacion_PAR, bool> expresionFiltrado = ObtenerExpresionEquals<PlantillaImportacion_PAR>(filtro);
    				return ConsultarPlantillaImportacion_PAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de PlantillaImportacion_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<PlantillaImportacion_PAR> ConsultarPlantillaImportacion_PAR(Func<PlantillaImportacion_PAR, bool> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			IObjectSet<PlantillaImportacion_PAR> objectSet = base.CreateObjectSet<PlantillaImportacion_PAR>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = PlantillaImportacion_PAR.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de PlantillaImportacion_PAR que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<PlantillaImportacion_PAR> ConsultarPlantillaImportacion_PAR(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			IObjectSet<PlantillaImportacion_PAR> objectSet = base.CreateObjectSet<PlantillaImportacion_PAR>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = PlantillaImportacion_PAR.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    	
            #endregion
                #region ObjectSet Properties
        public ObjectSet<PlantillaImportacion_PAR> PlantillaImportacion_PAR
        {
            get { return _plantillaImportacion_PAR  ?? (_plantillaImportacion_PAR = CreateObjectSet<PlantillaImportacion_PAR>("PlantillaImportacion_PAR")); }
        }
        private ObjectSet<PlantillaImportacion_PAR> _plantillaImportacion_PAR;

                #endregion
    }
}
