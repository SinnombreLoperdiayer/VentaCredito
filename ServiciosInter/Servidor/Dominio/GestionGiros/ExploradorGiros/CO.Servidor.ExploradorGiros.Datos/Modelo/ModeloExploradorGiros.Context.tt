<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#@
 output extension=".cs"#><#

var loader = new MetadataLoader(this);
var region = new CodeRegion(this);
var inputFile = @"ModeloExploradorGiros.edmx";
var ItemCollection = loader.CreateEdmItemCollection(inputFile);

Code = new CodeGenerationTools(this);
EFTools = new MetadataTools(this);
ObjectNamespace = Code.VsNamespaceSuggestion();
ModelNamespace = loader.GetModelNamespace(inputFile);

EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
if (container == null)
{
    return string.Empty;
}
#>
//------------------------------------------------------------------------------
// <auto-generated>
// <#=GetResourceString("Template_GeneratedCodeCommentLine1")#>
//
// <#=GetResourceString("Template_GeneratedCodeCommentLine2")#>
// <#=GetResourceString("Template_GeneratedCodeCommentLine3")#>
// </auto-generated>
//------------------------------------------------------------------------------

<#

if (!String.IsNullOrEmpty(ObjectNamespace))
{
#>
namespace <#=Code.EscapeNamespace(ObjectNamespace)#>
{
<#
    PushIndent(CodeRegion.GetIndent(1));
}

#>
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq.Expressions;
using System.Linq;
using System.Reflection;
using System.Data.Objects;
using System.Globalization;
<#
if (container.FunctionImports.Any())
{
#>

<#
}
#>

<#=Accessibility.ForType(container)#> partial class <#=Code.Escape(container)#> : DbContext
{
    public <#=Code.Escape(container)#>(string ConnectionString)
        : base(ConnectionString)
    {
				
<#
        WriteLazyLoadingEnabled(container);
#>
    }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        throw new UnintentionalCodeFirstException();
    }
		#region Metodos para filtrar

    /// <summary>
    /// Crea una expresion de tipo where equals para todos los filtros ingresados
    /// </summary>
    /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
    /// <param name="filtros">Filtros que se agregaran a la expresión equals</param>
    /// <returns>Expresion</returns>
    public Expression<Func<TLinqEntity, bool>> ObtenerExpresionEquals<TLinqEntity>(IDictionary<string, string> filtros)
    {
      List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();

      Expression<Func<TLinqEntity, bool>> lamExp = ArmarExpresionFiltrado<TLinqEntity>(filtros, "Equals");
      if (lamExp != null)
        lexList.Add(lamExp);

      if (lexList.Count == 0)
      {
        Expression<Func<TLinqEntity, bool>> lambda = x => 1 == 1;
        return lambda;
      }
      else
        return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
    }

    /// <summary>
    /// Crea una expresion de tipo where contains para todos los filtros ingresados
    /// </summary>
    /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
    /// <param name="filtros">Filtros que se agregaran a la expresión contains</param>
    /// <returns>Expresion</returns>
    public Expression<Func<TLinqEntity, bool>> ObtenerExpresionContains<TLinqEntity>(IDictionary<string, string> filtros)
    {
      List<LambdaExpression> lexList = new List<LambdaExpression>();

      LambdaExpression lamExp = ArmarExpresionFiltrado<TLinqEntity>(filtros, "Contains");
      if (lamExp != null)
        lexList.Add(lamExp);

      if (lexList.Count == 0)
      {
        Expression<Func<TLinqEntity, bool>> lambda = x => 1 == 1;
        return lambda;
      }
      else
        return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
    }

    /// <summary>
    /// Crea una expresion de tipo where para todos los filtros y expresiones where ingresadas
    /// </summary>
    /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
    /// <param name="filtros">Filtros que se agregaran a la expresión contains</param>
    /// <param name="where">Diccionario con la lista de expresiones where que se desean concatenar con los filtros</param>
    /// <returns>Expresion</returns>
    public Expression<Func<TLinqEntity, bool>> ObtenerFiltro<TLinqEntity>(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where)
    {
      List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();

      Expression<Func<TLinqEntity, bool>> lamExp = ArmarExpresionFiltrado<TLinqEntity>(filtros, "Contains");
      if (lamExp != null)
        lexList.Add(lamExp);

      foreach (KeyValuePair<LambdaExpression, OperadorLogico> expr in where)
      {
        if (lexList.Count == 0)
          lexList.Add((Expression<Func<TLinqEntity, bool>>)expr.Key);
        else
        {
          Expression<Func<TLinqEntity, bool>> bodyOuter = null;

          switch (expr.Value)
          {
            case OperadorLogico.And:

              bodyOuter = ((Expression<Func<TLinqEntity, bool>>)expr.Key).And((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
              break;
            case OperadorLogico.Or:
              bodyOuter = ((Expression<Func<TLinqEntity, bool>>)expr.Key).Or((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
              break;
          }

          lexList.Add(bodyOuter);
        }
      }

      if (lexList.Count == 0)
      {
        Expression<Func<TLinqEntity, bool>> lambda = x => 1 == 1;
        return lambda;
      }

      return (lexList[lexList.Count - 1]);
    }

    /// <summary>
    /// Crea una expresion lambda de tipo where a partir de los parámetros ingresados
    /// </summary>
    /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
    /// <param name="nombreCampo">Nombre del campo de la entidad sobre el cual se aplicará el operador de comparación</param>
    /// <param name="valor">Valor con el cual se comparará el campo de la entidad</param>
    /// <param name="operComparacion">Operacion de comparacion de la expresion</param>
    /// <param name="valor2">Valor utilizado en las expresiones cuyo operador de comparacion es el between</param>
    /// <returns>Expresion Lambda</returns>
    public LambdaExpression CrearExpresionLambda<TLinqEntity>(string nombreCampo, string valor, OperadorComparacion operComparacion, string valor2 = null)
    {
      LambdaExpression expresionLambda = null;
      ParameterExpression param = Expression.Parameter(typeof(TLinqEntity), nombreCampo);

      bool valido = false;
      PropertyInfo prop = typeof(TLinqEntity).GetProperty(nombreCampo);
      Type proptype = prop.PropertyType;

      Expression callExpr = Expression.MakeMemberAccess(param, prop);
      Expression valueExpr = Expression.Constant(valor);
      Expression body = null;

      if (proptype == typeof(string))
      {
        var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
        //body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
        valido = true;
      }

      else if (proptype == typeof(int) || proptype == typeof(Nullable) ||
          proptype == typeof(long) ||
          proptype == typeof(short) ||
          proptype == typeof(decimal) ||
          proptype == typeof(System.Decimal) ||
          proptype == typeof(System.Int16) ||
          proptype == typeof(System.Int32) ||
          proptype == typeof(System.Int64) ||
          proptype == typeof(System.Nullable<decimal>) ||
          proptype == typeof(System.Nullable<long>) ||
          proptype == typeof(System.Nullable<int>) ||
          proptype == typeof(System.Nullable<short>))
      {
        // Check if input data type matches
        object num = null;

        if (proptype == typeof(int) || proptype == typeof(System.Int32) || proptype == typeof(System.Nullable<int>))
        {
          int temp;
          if (int.TryParse(valor, out temp))
            num = temp;
        }

				if (proptype == typeof(decimal) || proptype == typeof(System.Decimal) || proptype == typeof(System.Nullable<decimal>))
        {
          decimal temp;
          if (decimal.TryParse(valor, out temp))
            num = temp;
        }

        if (proptype == typeof(short) || proptype == typeof(System.Int16) || proptype == typeof(System.Nullable<short>))
        {
          short temp;
          if (short.TryParse(valor, out temp))
            num = temp;
        }

        if (proptype == typeof(long) || proptype == typeof(System.Int64) || proptype == typeof(System.Nullable<long>))
        {
          long temp;
          if (long.TryParse(valor, out temp))
            num = temp;
        }

        if (num != null)
        {
          valueExpr = Expression.Constant(num, proptype);
          body = Expression.Equal(callExpr, valueExpr);
          valido = true;
        }
      }
      else if (proptype == typeof(DateTime) || proptype == typeof(Nullable))
      {
        DateTime date;
        CultureInfo cultura = new CultureInfo("es-CO");
        if (DateTime.TryParse(valor,  cultura, DateTimeStyles.None, out date))
        {
			 if (valor2 == null)
            valor2 = date.AddDays(1).ToString("yyyy/MM/dd");
          valueExpr = Expression.Constant(date, proptype);
          //Expression valueExpr2 = Expression.Constant(date.AddHours(24), proptype);
          //Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
          //Expression body1 = Expression.LessThan(callExpr, valueExpr2);
          //body = Expression.AndAlso(bodyBetween, body1);
          valido = true;
        }
      }
      else if (proptype == typeof(bool) || proptype == typeof(System.Nullable<bool>) || proptype == typeof(Nullable))
      {
        bool val;
        if (bool.TryParse(valor, out val))
        {
          valueExpr = Expression.Constant(val, proptype);
          //body = Expression.Equal(callExpr, valueExpr);
          valido = true;
        }
      }

      if (valido)
      {
        switch (operComparacion)
        {
          case OperadorComparacion.Equal:
            body = Expression.Equal(callExpr, valueExpr);
            break;
          case OperadorComparacion.NotEqual:
            body = Expression.NotEqual(callExpr, valueExpr);
            break;
          case OperadorComparacion.Contains:
            if (proptype == typeof(string))
            {
              var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
              body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
            }
            else
            {
              throw new Exception("El operador de comparación 'Contains' solo soporta campos de tipo de dato string");
            }
            break;
          case OperadorComparacion.Between:
            if (proptype == typeof(DateTime))
            {
              DateTime date;
              if (DateTime.TryParse(valor2, out date))
              {
                Expression valueExpr2 = Expression.Constant(date, proptype);
                Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
                Expression body1 = Expression.LessThan(callExpr, valueExpr2);
                body = Expression.AndAlso(bodyBetween, body1);
              }
              else
              {
                throw new Exception("El formato de Fecha para el segundo valor no es válido");
              }
            }
            else
            {
              throw new Exception("El operador de comparación 'Between' solo soporta campos de tipo de dato datetime");
            }
            break;
        }

        expresionLambda = Expression.Lambda(body, param);
      }

      if (expresionLambda == null)
        throw new Exception("Argumentos no válidos para construir la expresión lambda");

      return expresionLambda;
    }

    private Expression<Func<TLinqEntity, bool>> ArmarExpresionFiltrado<TLinqEntity>(IDictionary<string, string> filtros, string tipoFiltro)
    {
      List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();
      foreach (KeyValuePair<string, string> filtro in filtros)
      {
        OperadorComparacion opercomp = OperadorComparacion.Contains;
        PropertyInfo prop = typeof(TLinqEntity).GetProperty(filtro.Key);
        Type proptype = prop.PropertyType;
        if (proptype == typeof(string))
        {
          switch (tipoFiltro)
          {
            case "Equals":
              opercomp = OperadorComparacion.Equal;
              break;
            default:
              opercomp = OperadorComparacion.Contains;
              break;
          }
        }
        else if (proptype == typeof(int) ||
               proptype == typeof(long) ||
               proptype == typeof(short) ||
               proptype == typeof(decimal) ||
               proptype == typeof(System.Int16) ||
               proptype == typeof(System.Int32) ||
               proptype == typeof(System.Int64) ||
               proptype == typeof(System.Decimal) ||
               proptype == typeof(System.Nullable<long>) ||
               proptype == typeof(System.Nullable<int>) ||
               proptype == typeof(System.Nullable<short>) ||
               proptype == typeof(System.Nullable<decimal>) ||
               proptype == typeof(bool) ||
               proptype == typeof(System.Nullable<bool>))
        {
          opercomp = OperadorComparacion.Equal;
        }
        else if (proptype == typeof(DateTime) || proptype == typeof(System.Nullable<DateTime>))
        {
          opercomp = OperadorComparacion.Between;
        }

        Expression<Func<TLinqEntity, bool>> operLambda = (Expression<Func<TLinqEntity, bool>>)CrearExpresionLambda<TLinqEntity>(filtro.Key, filtro.Value, opercomp);
        if (lexList.Count == 0)
          lexList.Add(operLambda);
        else
        {
          Expression<Func<TLinqEntity, bool>> bodyOuter = null;
          bodyOuter = (operLambda).And(lexList[lexList.Count - 1]);

          lexList.Add(bodyOuter);
        }
      }

      if (lexList.Count > 0)
        return lexList[lexList.Count - 1];

      //List<ParameterExpression> paramList = new List<ParameterExpression>();
      //foreach (KeyValuePair<string, string> filtro in filtros)
      //{
      //  paramList.Add(Expression.Parameter(typeof(TLinqEntity), filtro.Key));
      //}

      //List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();
      //for (int i = 0; i < filtros.Count; i++)
      //{
      //  bool valido = false;
      //  PropertyInfo prop = typeof(TLinqEntity).GetProperty(filtros.ElementAt(i).Key);
      //  Type proptype = prop.PropertyType;

      //  Expression callExpr = Expression.MakeMemberAccess(paramList[i], prop);
      //  Expression valueExpr = Expression.Constant(filtros.ElementAt(i).Value.ToLower());
      //  Expression body = null;

      //  if (proptype == typeof(string))
      //  {
      //    var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
      //    if (tipoFiltro.Equals("Contains"))
      //      body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
      //    else if (tipoFiltro.Equals("Equals"))
      //      body = Expression.Call(toLower, typeof(string).GetMethod("Equals", new Type[] { typeof(string) }), valueExpr);
      //    valido = true;
      //  }

      //  else if (proptype == typeof(int) || proptype == typeof(Nullable) ||
      //          proptype == typeof(long) ||
      //          proptype == typeof(short) ||
      //          proptype == typeof(System.Int16) ||
      //          proptype == typeof(System.Int32) ||
      //          proptype == typeof(System.Int64) ||
      //          proptype == typeof(System.Nullable<long>) ||
      //          proptype == typeof(System.Nullable<int>) ||
      //          proptype == typeof(System.Nullable<short>))
      //  {
      //    // Check if input data type matches
      //    object num = null;

      //    if (proptype == typeof(int) || proptype == typeof(System.Int32) || proptype == typeof(System.Nullable<int>))
      //    {
      //      int temp;
      //      if (int.TryParse(filtros.ElementAt(i).Value, out temp))
      //        num = temp;
      //    }

      //    if (proptype == typeof(short) || proptype == typeof(System.Int16) || proptype == typeof(System.Nullable<short>))
      //    {
      //      short temp;
      //      if (short.TryParse(filtros.ElementAt(i).Value, out temp))
      //        num = temp;
      //    }

      //    if (proptype == typeof(long) || proptype == typeof(System.Int64) || proptype == typeof(System.Nullable<long>))
      //    {
      //      long temp;
      //      if (long.TryParse(filtros.ElementAt(i).Value, out temp))
      //        num = temp;
      //    }

      //    if (num != null)
      //    {
      //      valueExpr = Expression.Constant(num, proptype);
      //      body = Expression.Equal(callExpr, valueExpr);
      //      valido = true;
      //    }
      //  }
      //  else if (proptype == typeof(DateTime) || proptype == typeof(Nullable))
      //  {
      //    DateTime date;
      //    if (DateTime.TryParse(filtros.ElementAt(i).Value, out date))
      //    {
      //      valueExpr = Expression.Constant(date, proptype);
      //      Expression valueExpr2 = Expression.Constant(date.AddHours(24), proptype);
      //      Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
      //      Expression body1 = Expression.LessThan(callExpr, valueExpr2);
      //      body = Expression.AndAlso(bodyBetween, body1);
      //      valido = true;
      //    }
      //  }
      //  else if (proptype == typeof(bool) || proptype == typeof(Nullable))
      //  {
      //    bool val;
      //    if (bool.TryParse(filtros.ElementAt(i).Value, out val))
      //    {
      //      valueExpr = Expression.Constant(val, proptype);
      //      body = Expression.Equal(callExpr, valueExpr);
      //      valido = true;
      //    }
      //  }

      //  if (valido)
      //  {
      //    if (lexList.Count == 0)
      //    {
      //      lexList.Add((Expression<Func<TLinqEntity, bool>>)body);
      //    }
      //    else
      //    {
      //      Expression<Func<TLinqEntity, bool>> bodyOuter = null;

      //      bodyOuter = ((Expression<Func<TLinqEntity, bool>>)body).And((Expression<Func<TLinqEntity, bool>>)lexList[i - 1]);

      //      //Expression bodyOuter = Expression.AndAlso(
      //      //                    body,
      //      //                    Expression.Invoke(lexList[i - 1], paramList[i]));
      //      lexList.Add(bodyOuter);
      //    }
      //  }
      //}

      //if (lexList.Count > 0)
      //  return lexList[lexList.Count - 1];
      return null;
    }

    #endregion Metodos para filtrar
		
		<#
	region.Begin("Consultas", 2);
  foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
  {
	#>
	/// <summary>
		/// Retorna la lista de <#=Code.Escape(entitySet)#> que cumpla con las expresiones de filtrado y ordenamiento
      /// </summary>
		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
    	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
    	/// <param name="indicePagina">Índice de página a retornar</param>
    	/// <param name="registrosPorPagina">Registros por página</param>
    	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
    	/// <returns></returns>
			<#=Accessibility.ForReadOnlyProperty(entitySet)#> IEnumerable<<#=Code.Escape(entitySet.ElementType)#>> ConsultarContains<#=Code.Escape(entitySet)#>(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
		{
			Expression<Func<<#=Code.Escape(entitySet.ElementType)#>, bool>> expresionFiltrado = ObtenerExpresionContains<<#=Code.Escape(entitySet.ElementType)#>>(filtro);
			return Consultar<#=Code.Escape(entitySet)#>(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
		}

		/// <summary>
		/// Retorna la lista de <#=Code.Escape(entitySet)#> que cumpla con las expresiones de filtrado y ordenamiento
      /// </summary>
		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
    	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
    	/// <param name="indicePagina">Índice de página a retornar</param>
    	/// <param name="registrosPorPagina">Registros por página</param>
    	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
    	/// <returns></returns>
		<#=Accessibility.ForReadOnlyProperty(entitySet)#> IEnumerable<<#=Code.Escape(entitySet.ElementType)#>> ConsultarEquals<#=Code.Escape(entitySet)#>(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
		{
				Expression<Func<<#=Code.Escape(entitySet.ElementType)#>, bool>> expresionFiltrado = ObtenerExpresionEquals<<#=Code.Escape(entitySet.ElementType)#>>(filtro);
				return Consultar<#=Code.Escape(entitySet)#>(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
		}

		/// <summary>
		/// Retorna la lista de <#=Code.Escape(entitySet)#> que cumpla con las expresiones de filtrado y ordenamiento
      /// </summary>
		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
    	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
    	/// <param name="indicePagina">Índice de página a retornar</param>
    	/// <param name="registrosPorPagina">Registros por página</param>
    	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
    	/// <returns></returns>
		<#=Accessibility.ForReadOnlyProperty(entitySet)#> IEnumerable<<#=Code.Escape(entitySet.ElementType)#>> Consultar<#=Code.Escape(entitySet)#>(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
		{
				Expression<Func<<#=Code.Escape(entitySet.ElementType)#>, bool>> expresionFiltrado = ObtenerFiltro<<#=Code.Escape(entitySet.ElementType)#>>(filtros,where);
				return Consultar<#=Code.Escape(entitySet)#>(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
		}

		/// <summary>
		/// Retorna la lista de <#=Code.Escape(entitySet)#> que cumpla con las expresiones de filtrado y ordenamiento
      /// </summary>
		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
    	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
    	/// <param name="indicePagina">Índice de página a retornar</param>
    	/// <param name="registrosPorPagina">Registros por página</param>
    	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
    	/// <returns></returns>
		<#=Accessibility.ForReadOnlyProperty(entitySet)#> IEnumerable<<#=Code.Escape(entitySet.ElementType)#>> Consultar<#=Code.Escape(entitySet)#>(Expression<Func<<#=Code.Escape(entitySet.ElementType)#>, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
		{
			// Verificando parámetros para la consulta
			if (indicePagina < 0)
				throw new ArgumentException("Número de Página inválida");

			if (registrosPorPagina <= 0)
				throw new ArgumentException("Número de registros por página no válido");

			//Create associated IObjectSet and perform query			
			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<<#=Code.Escape(entitySet.ElementType)#>>();

				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
         
			if (campoOrdenamiento.Trim() == string.Empty)
         {
            string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
            return objectSet.OrdenarPor(llavePrimaria)
													  .Where(expresionFiltrado)										
                                         .Skip(indicePagina * registrosPorPagina)
                                         .Take(registrosPorPagina).ToList();
         }
			else
			{
				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
    													.Where(expresionFiltrado)										
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
    													.Where(expresionFiltrado)										
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
			}	
		}

		/// <summary>
      /// Retorna la lista de <#=Code.Escape(entitySet)#> que cumpla con la expresión de ordenamiento
      /// </summary>
    	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
    	/// <param name="indicePagina">Índice de página a retornar</param>
    	/// <param name="registrosPorPagina">Registros por página</param>
    	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
    	/// <returns></returns>
		<#=Accessibility.ForReadOnlyProperty(entitySet)#> IEnumerable<<#=Code.Escape(entitySet.ElementType)#>> Consultar<#=Code.Escape(entitySet)#>(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
		{
			// Verificando parámetros para la consulta
			if (indicePagina < 0)
				throw new ArgumentException("Página inválida");

			if (registrosPorPagina <= 0)
				throw new ArgumentException("Número de registros por página no válido");

			//Create associated IObjectSet and perform query
			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<<#=Code.Escape(entitySet.ElementType)#>>();
		
		   totalRegistros = objectSet.Count();
         
			if (campoOrdenamiento.Trim() == string.Empty)
         {
            string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
            return objectSet.OrdenarPor(llavePrimaria)
                                         .Skip(indicePagina * registrosPorPagina)
                                         .Take(registrosPorPagina).ToList();
         }
			else
			{
				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
													.Skip(indicePagina * registrosPorPagina)
													.Take(registrosPorPagina)
													.ToList()
											 :
									objectSet.OrdenarPorDescendente(campoOrdenamiento)
													.Skip(indicePagina * registrosPorPagina)
													.Take(registrosPorPagina)
													.ToList();
			}
		}
	<#
}
	region.End();	
#>

		#region Propiedades
<#	 
	foreach (var entitySet in container.BaseEntitySets.OfType<EntitySet>())
    {
#>
    <#=Accessibility.ForReadOnlyProperty(entitySet)#> DbSet<<#=Code.Escape(entitySet.ElementType)#>> <#=Code.Escape(entitySet)#> { get; set; }
<#
    }
		
    foreach (var edmFunction in container.FunctionImports)
    {
        WriteFunctionImport(edmFunction, false);
    }
#>
	#endregion
}
<#

if (!String.IsNullOrEmpty(ObjectNamespace))
{
    PopIndent();
#>
		/// <summary>
    /// Operadores de comparación en una sentencia where
    /// </summary>
    public enum OperadorComparacion
    {
        Equal,
        NotEqual,
        Contains,
        Between
    }

    /// <summary>
    /// Operadores lógicos en una sentencia where
    /// </summary>
    public enum OperadorLogico
    {
        Or,
        And
    }    

		  public class ParameterRebinder : ExpressionVisitor
  {
    private readonly Dictionary<ParameterExpression, ParameterExpression> map;

    public ParameterRebinder(Dictionary<ParameterExpression, ParameterExpression> map)
    {
      this.map = map ?? new Dictionary<ParameterExpression, ParameterExpression>();
    }

    public static Expression ReplaceParameters(Dictionary<ParameterExpression, ParameterExpression> map, Expression exp)
    {
      return new ParameterRebinder(map).Visit(exp);
    }

    protected override Expression VisitParameter(ParameterExpression p)
    {
      ParameterExpression replacement;
      if (map.TryGetValue(p, out replacement))
      {
        p = replacement;
      }
      return base.VisitParameter(p);
    }
  }

  public static class Utility
  {
    public static Expression<T> Compose<T>(this Expression<T> first, Expression<T> second, Func<Expression, Expression, Expression> merge)
    {
      // build parameter map (from parameters of second to parameters of first)
      var map = first.Parameters.Select((f, i) => new { f, s = second.Parameters[i] }).ToDictionary(p => p.s, p => p.f);

      // replace parameters in the second lambda expression with parameters from the first
      var secondBody = ParameterRebinder.ReplaceParameters(map, second.Body);

      // apply composition of lambda expression bodies to parameters from the first expression
      return Expression.Lambda<T>(merge(first.Body, secondBody), first.Parameters);
    }

    public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> first, Expression<Func<T, bool>> second)
    {
      return first.Compose(second, Expression.And);
    }

    public static Expression<Func<T, bool>> Or<T>(this Expression<Func<T, bool>> first, Expression<Func<T, bool>> second)
    {
      return first.Compose(second, Expression.Or);
    }
  }

	  public static class AuditExtensions
    {
      /// <summary>
      /// Adds Auditing to an ObjectContext for the specified <paramref name="fromType"/>.
      /// </summary>
      /// <typeparam name="fromType">The source entity type (including derivatives) to audit changes to.</typeparam>
      /// <typeparam name="toType">The target entity type that audit records will be stored in.</typeparam>
      /// <param name="context">The ObjectContext for which Auditing should be enabled.</param>
      /// <param name="mapping">A lambda expression that maps the changed <paramref name="fromType"/> entity to a <paramref name="toType"/> audit record.</param>
      /// <param name="addToContext">A lambda expression that adds the audit entity to an entity collection.</param>
      public static void Audit<fromType, toType>(
          this DbContext context,
          Func<IDataRecord, EntityState, toType> mapping,
          Action<toType> addToContext)
      {
        IObjectContextAdapter oc = context as IObjectContextAdapter;
        oc.ObjectContext.SavingChanges +=
            new EventHandler((o, e) =>
                CreateAuditRecord<fromType, toType>(context, mapping, addToContext));
      }

      /// <summary>
      /// Helper function that is called during ObjectContext.SavingChanges, and is responsible for managing the
      /// process of mapping all changed entities to an audit entity, and adding them to an entity collection.
      /// </summary>
      /// <remarks>
      /// Note that at present this function will be called once for every entity type that is being audited. If
      /// you don't like this it should be easy to optimize it.
      /// </remarks>
      /// <typeparam name="fromType">The source entity type (including derivatives) to audit changes to.</typeparam>
      /// <typeparam name="toType">The target entity type that audit records will be stored in.</typeparam>
      /// <param name="context">The ObjectContext for which Auditing should be enabled.</param>
      /// <param name="mapping">A lambda expression that maps the changed <paramref name="fromType"/> entity to a <paramref name="toType"/> audit record.</param>
      /// <param name="addToContext">A lambda expression that adds the audit entity to an entity collection.</param>
      private static void CreateAuditRecord<fromType, toType>(
          DbContext context,
          Func<IDataRecord, EntityState, toType> mapping,
          Action<toType> addToContext)
      {
        IObjectContextAdapter oc = context as IObjectContextAdapter;
        oc.ObjectContext.DetectChanges();
        // get a list of changes to audit
        IEnumerable<ObjectStateEntry> entities =
            from e in oc.ObjectContext.ObjectStateManager.GetObjectStateEntries(
                EntityState.Modified | EntityState.Deleted)
            where
                e.IsRelationship == false &&
                typeof(fromType).IsAssignableFrom(e.Entity.GetType())
            select e;

        foreach (ObjectStateEntry item in entities)
        {
          // map the changed item to an audit record entry
          toType auditRecord = mapping(item.OriginalValues, item.State);
          // and add it to the object context so that it is persisted for us
          addToContext(auditRecord);
        }
      }

      /// <summary>
      /// Retrieves a fields value from an IDataRecord (including a DbDataRecord) in a strongly typed,
      /// compile-time checked fashion. This overload assumes the IDataRecord represents an EntityObject
      /// for which a property's value should be retrieved.
      /// </summary>
      /// <typeparam name="E">The Entity type the IDataRecord represents</typeparam>
      /// <typeparam name="T">The data type of the field</typeparam>
      /// <param name="record">The IDataRecord that contains the data</param>
      /// <param name="propertySelector">An expression that identifies the entity member to retrieve</param>
      /// <returns>The field's value.</returns>
      /// <example>
      /// <code>
      /// IDataRecord record = GetRecord();
      /// string name = record.Field&lt;Person, string>(person => person.Name);
      /// int age = record.Field&lt;Person, int>(person => person.Age);
      /// DateTime createdDate = record.Field&lt;Person, DateTime>(person => person.CreatedDate);
      /// </code>
      /// </example>
      public static T Field<E, T>(this IDataRecord record, System.Linq.Expressions.Expression<Func<E, T>> propertySelector)
      {
        System.Linq.Expressions.MemberExpression memberExpression = propertySelector.Body as System.Linq.Expressions.MemberExpression;
        System.Reflection.MemberInfo propertyInfo = memberExpression.Member;

        int fieldIndex = record.GetOrdinal(propertyInfo.Name);
        return Field<T>(record, fieldIndex);
      }

      /// <summary>
      /// Retrieves a fields value from an IDataRecord in a strongly typed fashion.
      /// </summary>
      /// <remarks>
      /// This code is based on similar functionality in the EFExtensions project; see
      /// http://code.msdn.microsoft.com/EFExtensions
      /// </remarks>
      /// <typeparam name="T">The data type of the field.</typeparam>
      /// <param name="record">The IDataRecord that contains the data</param>
      /// <param name="ordinal">The field's index in the IDataRecord</param>
      /// <returns>The field's value.</returns>
      public static T Field<T>(this IDataRecord record, int ordinal)
      {
        object value = record.IsDBNull(ordinal) ? null : record.GetValue(ordinal);
        return (T)value;
      }
    }

		/// <summary>
   /// Extensión para ordenamiento por nombre del campo
   /// </summary>
   public static class OrderExtension
   {
		/// <sumary>
		/// Ordena usando una expresión de ordenamiento, por ejemplo:
		///		iqueryable.OrdenarUsandoExpresion("Employee.LastName, Freight DESC")
		/// </sumary>
      public static IOrderedQueryable<TEntity> OrdenarUsandoExpresion<TEntity>(this IQueryable<TEntity> source, string sortExpression) where TEntity : class
      {
             String[] orderFields = sortExpression.Split(',');
             IOrderedQueryable<TEntity> result = null;
              bool sortDescending=false;
              if (sortExpression.Contains(" DESC"))
              {
                  sortDescending = true;
              }
             for (int currentFieldIndex = 0; currentFieldIndex < orderFields.Length; currentFieldIndex++)
             {
                String[] expressionPart = orderFields[currentFieldIndex].Trim().Split(' ');
                String sortField = expressionPart[0];
                //Boolean sortDescending = (expressionPart.Length == 2) && (expressionPart[1].Equals("DESC", StringComparison.OrdinalIgnoreCase));
                if (sortDescending)
                {
                   result = currentFieldIndex == 0 ? source.OrdenarPorDescendente(sortField) : result.EntoncesPorDescendente(sortField);
                }
                else
                {
                   result = currentFieldIndex == 0 ? source.OrdenarPor(sortField) : result.EntoncesPor(sortField);
                }
             }
             return result;
      }

      public static IOrderedQueryable<TEntity> OrdenarPor<TEntity>(this IQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "OrderBy", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      public static IOrderedQueryable<TEntity> OrdenarPorDescendente<TEntity>(this IQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "OrderByDescending", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      public static IOrderedQueryable<TEntity> EntoncesPor<TEntity>(this IOrderedQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "ThenBy", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      public static IOrderedQueryable<TEntity> EntoncesPorDescendente<TEntity>(this IOrderedQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "ThenByDescending", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      private static MethodCallExpression GenerateMethodCall<TEntity>(IQueryable<TEntity> source, string methodName, String fieldName) where TEntity : class
      {
         Type type = typeof(TEntity);
         Type selectorResultType;
         LambdaExpression selector = GenerateSelector<TEntity>(fieldName, out selectorResultType);
         MethodCallExpression resultExp = Expression.Call(typeof(Queryable), methodName,
                         new Type[] { type, selectorResultType },
                         source.Expression, Expression.Quote(selector));
         return resultExp;
      }

      private static LambdaExpression GenerateSelector<TEntity>(String propertyName, out Type resultType) where TEntity : class
      {
         // Create a parameter to pass into the Lambda expression (Entity => Entity.OrderByField).
         var parameter = Expression.Parameter(typeof(TEntity), "Entity");
         //  create the selector part, but support child properties
         PropertyInfo property;
         Expression propertyAccess;
         if (propertyName.Contains('.'))
         {
            // support to be sorted on child fields.
            String[] childProperties = propertyName.Split('.');
            property = typeof(TEntity).GetProperty(childProperties[0], BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            propertyAccess = Expression.MakeMemberAccess(parameter, property);
            for (int i = 1; i < childProperties.Length; i++)
            {
               property = property.PropertyType.GetProperty(childProperties[i], BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
               propertyAccess = Expression.MakeMemberAccess(propertyAccess, property);
            }
         }
         else
         {
            property = typeof(TEntity).GetProperty(propertyName, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            propertyAccess = Expression.MakeMemberAccess(parameter, property);
         }
         resultType = property.PropertyType;
         // Create the order by expression.
         return Expression.Lambda(propertyAccess, parameter);
      }
   }
}

<#
}
#>
<#+
string ModelNamespace { get; set; }
string ObjectNamespace { get; set; }
CodeGenerationTools Code { get; set; }
MetadataTools EFTools { get; set; }

string GetResourceString(string resourceName)
{
	if(_resourceManager == null)
	{
		_resourceManager = new System.Resources.ResourceManager("System.Data.Entity.Design", typeof(System.Data.Entity.Design.MetadataItemCollectionFactory).Assembly);
	}
	
    return _resourceManager.GetString(resourceName, null);
}
System.Resources.ResourceManager _resourceManager;

void WriteLazyLoadingEnabled(EntityContainer container)
{
   string lazyLoadingAttributeValue = null;
   var lazyLoadingAttributeName = MetadataConstants.EDM_ANNOTATION_09_02 + ":LazyLoadingEnabled";
   if(MetadataTools.TryGetStringMetadataPropertySetting(container, lazyLoadingAttributeName, out lazyLoadingAttributeValue))
   {
       bool isLazyLoading;
       if(bool.TryParse(lazyLoadingAttributeValue, out isLazyLoading) && !isLazyLoading)
       {
#>
        this.Configuration.LazyLoadingEnabled = false;
<#+
       }
   }
}

void WriteFunctionImport(EdmFunction edmFunction, bool includeMergeOption)
{
    var parameters = FunctionImportParameter.Create(edmFunction.Parameters, Code, EFTools);
    var paramList = String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName).ToArray());
    var returnType = edmFunction.ReturnParameter == null ? null : EFTools.GetElementType(edmFunction.ReturnParameter.TypeUsage);
    var processedReturn = returnType == null ? "int" : "ObjectResult<" + MultiSchemaEscape(returnType) + ">";

    if (includeMergeOption)
    {
        paramList = Code.StringAfter(paramList, ", ") + "MergeOption mergeOption";
    }
#>

    <#=AccessibilityAndVirtual(Accessibility.ForMethod(edmFunction))#> <#=processedReturn#> <#=Code.Escape(edmFunction)#>(<#=paramList#>)
    {
<#+
        if(returnType != null && (returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType ||
                                  returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.ComplexType))
        {
#>
        ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(<#=MultiSchemaEscape(returnType)#>).Assembly);

<#+
        }

        foreach (var parameter in parameters.Where(p => p.NeedsLocalVariable))
        {
            var isNotNull = parameter.IsNullableOfT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null";
            var notNullInit = "new ObjectParameter(\"" + parameter.EsqlParameterName + "\", " + parameter.FunctionParameterName + ")";
            var nullInit = "new ObjectParameter(\"" + parameter.EsqlParameterName + "\", typeof(" + parameter.RawClrTypeName + "))";
#>
        var <#=parameter.LocalVariableName#> = <#=isNotNull#> ?
            <#=notNullInit#> :
            <#=nullInit#>;

<#+
        }

        var genericArg = returnType == null ? "" : "<" + MultiSchemaEscape(returnType) + ">";
        var callParams = Code.StringBefore(", ", String.Join(", ", parameters.Select(p => p.ExecuteParameterName).ToArray()));

        if (includeMergeOption)
        {
            callParams = ", mergeOption" + callParams;
        }
#>
        return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<#=genericArg#>("<#=edmFunction.Name#>"<#=callParams#>);
    }
<#+
    if(!includeMergeOption && returnType != null && returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
    {
        WriteFunctionImport(edmFunction, true);
    }
}

string AccessibilityAndVirtual(string accessibility)
{
    return accessibility + (accessibility != "private" ? " virtual" : "");
}

string MultiSchemaEscape(TypeUsage usage)
{
    var type = usage.EdmType as StructuralType;
    return type != null && type.NamespaceName != ModelNamespace ?
        Code.CreateFullName(Code.EscapeNamespace(type.NamespaceName), Code.Escape(type)) :
        Code.Escape(usage);
}

#>