//------------------------------------------------------------------------------
// <auto-generated>
//    Este código se generó a partir de una plantilla.
//
//    Los cambios manuales en este archivo pueden causar un comportamiento inesperado de la aplicación.
//    Los cambios manuales en este archivo se sobrescribirán si se regenera el código.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CO.Servidor.Produccion.Datos.Modelo
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.Entity;
    using System.Data.Entity.Infrastructure;
    using System.Linq.Expressions;
    using System.Linq;
    using System.Reflection;
    using System.Data.Objects;
    using System.Globalization;
    
    
    public partial class ModeloProduccion : DbContext
    {
        public ModeloProduccion(string ConnectionString)
            : base(ConnectionString)
        {
    				((IObjectContextAdapter)this).ObjectContext.CommandTimeout = 5000;
        }
    
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            throw new UnintentionalCodeFirstException();
        }
    		#region Metodos para filtrar
    
        /// <summary>
        /// Crea una expresion de tipo where equals para todos los filtros ingresados
        /// </summary>
        /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
        /// <param name="filtros">Filtros que se agregaran a la expresión equals</param>
        /// <returns>Expresion</returns>
        public Expression<Func<TLinqEntity, bool>> ObtenerExpresionEquals<TLinqEntity>(IDictionary<string, string> filtros)
        {
          List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();
    
          Expression<Func<TLinqEntity, bool>> lamExp = ArmarExpresionFiltrado<TLinqEntity>(filtros, "Equals");
          if (lamExp != null)
            lexList.Add(lamExp);
    
          if (lexList.Count == 0)
          {
            Expression<Func<TLinqEntity, bool>> lambda = x => 1 == 1;
            return lambda;
          }
          else
            return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
        }
    
        /// <summary>
        /// Crea una expresion de tipo where contains para todos los filtros ingresados
        /// </summary>
        /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
        /// <param name="filtros">Filtros que se agregaran a la expresión contains</param>
        /// <returns>Expresion</returns>
        public Expression<Func<TLinqEntity, bool>> ObtenerExpresionContains<TLinqEntity>(IDictionary<string, string> filtros)
        {
          List<LambdaExpression> lexList = new List<LambdaExpression>();
    
          LambdaExpression lamExp = ArmarExpresionFiltrado<TLinqEntity>(filtros, "Contains");
          if (lamExp != null)
            lexList.Add(lamExp);
    
          if (lexList.Count == 0)
          {
            Expression<Func<TLinqEntity, bool>> lambda = x => 1 == 1;
            return lambda;
          }
          else
            return ((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
        }
    
        /// <summary>
        /// Crea una expresion de tipo where para todos los filtros y expresiones where ingresadas
        /// </summary>
        /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
        /// <param name="filtros">Filtros que se agregaran a la expresión contains</param>
        /// <param name="where">Diccionario con la lista de expresiones where que se desean concatenar con los filtros</param>
        /// <returns>Expresion</returns>
        public Expression<Func<TLinqEntity, bool>> ObtenerFiltro<TLinqEntity>(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where)
        {
          List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();
    
          Expression<Func<TLinqEntity, bool>> lamExp = ArmarExpresionFiltrado<TLinqEntity>(filtros, "Contains");
          if (lamExp != null)
            lexList.Add(lamExp);
    
          foreach (KeyValuePair<LambdaExpression, OperadorLogico> expr in where)
          {
            if (lexList.Count == 0)
              lexList.Add((Expression<Func<TLinqEntity, bool>>)expr.Key);
            else
            {
              Expression<Func<TLinqEntity, bool>> bodyOuter = null;
    
              switch (expr.Value)
              {
                case OperadorLogico.And:
    
                  bodyOuter = ((Expression<Func<TLinqEntity, bool>>)expr.Key).And((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
                  break;
                case OperadorLogico.Or:
                  bodyOuter = ((Expression<Func<TLinqEntity, bool>>)expr.Key).Or((Expression<Func<TLinqEntity, bool>>)lexList[lexList.Count - 1]);
                  break;
              }
    
              lexList.Add(bodyOuter);
            }
          }
    
          if (lexList.Count == 0)
          {
            Expression<Func<TLinqEntity, bool>> lambda = x => 1 == 1;
            return lambda;
          }
    
          return (lexList[lexList.Count - 1]);
        }
    
        /// <summary>
        /// Crea una expresion lambda de tipo where a partir de los parámetros ingresados
        /// </summary>
        /// <typeparam name="TLinqEntity">Entidad sobre la cual se creará la expresion</typeparam>
        /// <param name="nombreCampo">Nombre del campo de la entidad sobre el cual se aplicará el operador de comparación</param>
        /// <param name="valor">Valor con el cual se comparará el campo de la entidad</param>
        /// <param name="operComparacion">Operacion de comparacion de la expresion</param>
        /// <param name="valor2">Valor utilizado en las expresiones cuyo operador de comparacion es el between</param>
        /// <returns>Expresion Lambda</returns>
        public LambdaExpression CrearExpresionLambda<TLinqEntity>(string nombreCampo, string valor, OperadorComparacion operComparacion, string valor2 = null)
        {
          LambdaExpression expresionLambda = null;
          ParameterExpression param = Expression.Parameter(typeof(TLinqEntity), nombreCampo);
    
          bool valido = false;
          PropertyInfo prop = typeof(TLinqEntity).GetProperty(nombreCampo);
          Type proptype = prop.PropertyType;
    
          Expression callExpr = Expression.MakeMemberAccess(param, prop);
          Expression valueExpr = Expression.Constant(valor);
          Expression body = null;
    
          if (proptype == typeof(string))
          {
            var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
            //body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
            valido = true;
          }
    
          else if (proptype == typeof(int) || proptype == typeof(Nullable) ||
              proptype == typeof(long) ||
              proptype == typeof(short) ||
              proptype == typeof(decimal) ||
              proptype == typeof(System.Decimal) ||
              proptype == typeof(System.Int16) ||
              proptype == typeof(System.Int32) ||
              proptype == typeof(System.Int64) ||
              proptype == typeof(System.Nullable<decimal>) ||
              proptype == typeof(System.Nullable<long>) ||
              proptype == typeof(System.Nullable<int>) ||
              proptype == typeof(System.Nullable<short>))
          {
            // Check if input data type matches
            object num = null;
    
            if (proptype == typeof(int) || proptype == typeof(System.Int32) || proptype == typeof(System.Nullable<int>))
            {
              int temp;
              if (int.TryParse(valor, out temp))
                num = temp;
            }
    
    				if (proptype == typeof(decimal) || proptype == typeof(System.Decimal) || proptype == typeof(System.Nullable<decimal>))
            {
              decimal temp;
              if (decimal.TryParse(valor, out temp))
                num = temp;
            }
    
            if (proptype == typeof(short) || proptype == typeof(System.Int16) || proptype == typeof(System.Nullable<short>))
            {
              short temp;
              if (short.TryParse(valor, out temp))
                num = temp;
            }
    
            if (proptype == typeof(long) || proptype == typeof(System.Int64) || proptype == typeof(System.Nullable<long>))
            {
              long temp;
              if (long.TryParse(valor, out temp))
                num = temp;
            }
    
            if (num != null)
            {
              valueExpr = Expression.Constant(num, proptype);
              body = Expression.Equal(callExpr, valueExpr);
              valido = true;
            }
          }
          else if (proptype == typeof(DateTime) || proptype == typeof(Nullable))
          {
            DateTime date;
            CultureInfo cultura = new CultureInfo("es-CO");
            if (DateTime.TryParse(valor,  cultura, DateTimeStyles.None, out date))
            {
    			 if (valor2 == null)
                valor2 = date.AddDays(1).ToString("yyyy/MM/dd");
              valueExpr = Expression.Constant(date, proptype);
              //Expression valueExpr2 = Expression.Constant(date.AddHours(24), proptype);
              //Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
              //Expression body1 = Expression.LessThan(callExpr, valueExpr2);
              //body = Expression.AndAlso(bodyBetween, body1);
              valido = true;
            }
          }
          else if (proptype == typeof(bool) || proptype == typeof(System.Nullable<bool>) || proptype == typeof(Nullable))
          {
            bool val;
            if (bool.TryParse(valor, out val))
            {
              valueExpr = Expression.Constant(val, proptype);
              //body = Expression.Equal(callExpr, valueExpr);
              valido = true;
            }
          }
    
          if (valido)
          {
            switch (operComparacion)
            {
              case OperadorComparacion.Equal:
                body = Expression.Equal(callExpr, valueExpr);
                break;
              case OperadorComparacion.NotEqual:
                body = Expression.NotEqual(callExpr, valueExpr);
                break;
              case OperadorComparacion.Contains:
                if (proptype == typeof(string))
                {
                  var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
                  body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
                }
                else
                {
                  throw new Exception("El operador de comparación 'Contains' solo soporta campos de tipo de dato string");
                }
                break;
              case OperadorComparacion.Between:
                if (proptype == typeof(DateTime))
                {
                  DateTime date;
                  if (DateTime.TryParse(valor2, out date))
                  {
                    Expression valueExpr2 = Expression.Constant(date, proptype);
                    Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
                    Expression body1 = Expression.LessThan(callExpr, valueExpr2);
                    body = Expression.AndAlso(bodyBetween, body1);
                  }
                  else
                  {
                    throw new Exception("El formato de Fecha para el segundo valor no es válido");
                  }
                }
                else
                {
                  throw new Exception("El operador de comparación 'Between' solo soporta campos de tipo de dato datetime");
                }
                break;
            }
    
            expresionLambda = Expression.Lambda(body, param);
          }
    
          if (expresionLambda == null)
            throw new Exception("Argumentos no válidos para construir la expresión lambda");
    
          return expresionLambda;
        }
    
        private Expression<Func<TLinqEntity, bool>> ArmarExpresionFiltrado<TLinqEntity>(IDictionary<string, string> filtros, string tipoFiltro)
        {
          List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();
          foreach (KeyValuePair<string, string> filtro in filtros)
          {
            OperadorComparacion opercomp = OperadorComparacion.Contains;
            PropertyInfo prop = typeof(TLinqEntity).GetProperty(filtro.Key);
            Type proptype = prop.PropertyType;
            if (proptype == typeof(string))
            {
              switch (tipoFiltro)
              {
                case "Equals":
                  opercomp = OperadorComparacion.Equal;
                  break;
                default:
                  opercomp = OperadorComparacion.Contains;
                  break;
              }
            }
            else if (proptype == typeof(int) ||
                   proptype == typeof(long) ||
                   proptype == typeof(short) ||
                   proptype == typeof(decimal) ||
                   proptype == typeof(System.Int16) ||
                   proptype == typeof(System.Int32) ||
                   proptype == typeof(System.Int64) ||
                   proptype == typeof(System.Decimal) ||
                   proptype == typeof(System.Nullable<long>) ||
                   proptype == typeof(System.Nullable<int>) ||
                   proptype == typeof(System.Nullable<short>) ||
                   proptype == typeof(System.Nullable<decimal>) ||
                   proptype == typeof(bool) ||
                   proptype == typeof(System.Nullable<bool>))
            {
              opercomp = OperadorComparacion.Equal;
            }
            else if (proptype == typeof(DateTime) || proptype == typeof(System.Nullable<DateTime>))
            {
              opercomp = OperadorComparacion.Between;
            }
    
            Expression<Func<TLinqEntity, bool>> operLambda = (Expression<Func<TLinqEntity, bool>>)CrearExpresionLambda<TLinqEntity>(filtro.Key, filtro.Value, opercomp);
            if (lexList.Count == 0)
              lexList.Add(operLambda);
            else
            {
              Expression<Func<TLinqEntity, bool>> bodyOuter = null;
              bodyOuter = (operLambda).And(lexList[lexList.Count - 1]);
    
              lexList.Add(bodyOuter);
            }
          }
    
          if (lexList.Count > 0)
            return lexList[lexList.Count - 1];
    
          //List<ParameterExpression> paramList = new List<ParameterExpression>();
          //foreach (KeyValuePair<string, string> filtro in filtros)
          //{
          //  paramList.Add(Expression.Parameter(typeof(TLinqEntity), filtro.Key));
          //}
    
          //List<Expression<Func<TLinqEntity, bool>>> lexList = new List<Expression<Func<TLinqEntity, bool>>>();
          //for (int i = 0; i < filtros.Count; i++)
          //{
          //  bool valido = false;
          //  PropertyInfo prop = typeof(TLinqEntity).GetProperty(filtros.ElementAt(i).Key);
          //  Type proptype = prop.PropertyType;
    
          //  Expression callExpr = Expression.MakeMemberAccess(paramList[i], prop);
          //  Expression valueExpr = Expression.Constant(filtros.ElementAt(i).Value.ToLower());
          //  Expression body = null;
    
          //  if (proptype == typeof(string))
          //  {
          //    var toLower = Expression.Call(callExpr, typeof(string).GetMethod("ToLower", System.Type.EmptyTypes));
          //    if (tipoFiltro.Equals("Contains"))
          //      body = Expression.Call(toLower, typeof(string).GetMethod("Contains", new Type[] { typeof(string) }), valueExpr);
          //    else if (tipoFiltro.Equals("Equals"))
          //      body = Expression.Call(toLower, typeof(string).GetMethod("Equals", new Type[] { typeof(string) }), valueExpr);
          //    valido = true;
          //  }
    
          //  else if (proptype == typeof(int) || proptype == typeof(Nullable) ||
          //          proptype == typeof(long) ||
          //          proptype == typeof(short) ||
          //          proptype == typeof(System.Int16) ||
          //          proptype == typeof(System.Int32) ||
          //          proptype == typeof(System.Int64) ||
          //          proptype == typeof(System.Nullable<long>) ||
          //          proptype == typeof(System.Nullable<int>) ||
          //          proptype == typeof(System.Nullable<short>))
          //  {
          //    // Check if input data type matches
          //    object num = null;
    
          //    if (proptype == typeof(int) || proptype == typeof(System.Int32) || proptype == typeof(System.Nullable<int>))
          //    {
          //      int temp;
          //      if (int.TryParse(filtros.ElementAt(i).Value, out temp))
          //        num = temp;
          //    }
    
          //    if (proptype == typeof(short) || proptype == typeof(System.Int16) || proptype == typeof(System.Nullable<short>))
          //    {
          //      short temp;
          //      if (short.TryParse(filtros.ElementAt(i).Value, out temp))
          //        num = temp;
          //    }
    
          //    if (proptype == typeof(long) || proptype == typeof(System.Int64) || proptype == typeof(System.Nullable<long>))
          //    {
          //      long temp;
          //      if (long.TryParse(filtros.ElementAt(i).Value, out temp))
          //        num = temp;
          //    }
    
          //    if (num != null)
          //    {
          //      valueExpr = Expression.Constant(num, proptype);
          //      body = Expression.Equal(callExpr, valueExpr);
          //      valido = true;
          //    }
          //  }
          //  else if (proptype == typeof(DateTime) || proptype == typeof(Nullable))
          //  {
          //    DateTime date;
          //    if (DateTime.TryParse(filtros.ElementAt(i).Value, out date))
          //    {
          //      valueExpr = Expression.Constant(date, proptype);
          //      Expression valueExpr2 = Expression.Constant(date.AddHours(24), proptype);
          //      Expression bodyBetween = Expression.GreaterThanOrEqual(callExpr, valueExpr);
          //      Expression body1 = Expression.LessThan(callExpr, valueExpr2);
          //      body = Expression.AndAlso(bodyBetween, body1);
          //      valido = true;
          //    }
          //  }
          //  else if (proptype == typeof(bool) || proptype == typeof(Nullable))
          //  {
          //    bool val;
          //    if (bool.TryParse(filtros.ElementAt(i).Value, out val))
          //    {
          //      valueExpr = Expression.Constant(val, proptype);
          //      body = Expression.Equal(callExpr, valueExpr);
          //      valido = true;
          //    }
          //  }
    
          //  if (valido)
          //  {
          //    if (lexList.Count == 0)
          //    {
          //      lexList.Add((Expression<Func<TLinqEntity, bool>>)body);
          //    }
          //    else
          //    {
          //      Expression<Func<TLinqEntity, bool>> bodyOuter = null;
    
          //      bodyOuter = ((Expression<Func<TLinqEntity, bool>>)body).And((Expression<Func<TLinqEntity, bool>>)lexList[i - 1]);
    
          //      //Expression bodyOuter = Expression.AndAlso(
          //      //                    body,
          //      //                    Expression.Invoke(lexList[i - 1], paramList[i]));
          //      lexList.Add(bodyOuter);
          //    }
          //  }
          //}
    
          //if (lexList.Count > 0)
          //  return lexList[lexList.Count - 1];
          return null;
        }
    
        #endregion Metodos para filtrar
    		
    		    #region Consultas
    	/// <summary>
    		/// Retorna la lista de MotivoNovedad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<MotivoNovedad_PRO> ConsultarContainsMotivoNovedad_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<MotivoNovedad_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<MotivoNovedad_PRO>(filtro);
    			return ConsultarMotivoNovedad_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de MotivoNovedad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<MotivoNovedad_PRO> ConsultarEqualsMotivoNovedad_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<MotivoNovedad_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<MotivoNovedad_PRO>(filtro);
    				return ConsultarMotivoNovedad_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de MotivoNovedad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<MotivoNovedad_PRO> ConsultarMotivoNovedad_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<MotivoNovedad_PRO, bool>> expresionFiltrado = ObtenerFiltro<MotivoNovedad_PRO>(filtros,where);
    				return ConsultarMotivoNovedad_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de MotivoNovedad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<MotivoNovedad_PRO> ConsultarMotivoNovedad_PRO(Expression<Func<MotivoNovedad_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<MotivoNovedad_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de MotivoNovedad_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<MotivoNovedad_PRO> ConsultarMotivoNovedad_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<MotivoNovedad_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de RetencionLiqGlobal_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<RetencionLiqGlobal_PRO> ConsultarContainsRetencionLiqGlobal_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<RetencionLiqGlobal_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<RetencionLiqGlobal_PRO>(filtro);
    			return ConsultarRetencionLiqGlobal_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionLiqGlobal_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqGlobal_PRO> ConsultarEqualsRetencionLiqGlobal_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionLiqGlobal_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<RetencionLiqGlobal_PRO>(filtro);
    				return ConsultarRetencionLiqGlobal_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionLiqGlobal_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqGlobal_PRO> ConsultarRetencionLiqGlobal_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionLiqGlobal_PRO, bool>> expresionFiltrado = ObtenerFiltro<RetencionLiqGlobal_PRO>(filtros,where);
    				return ConsultarRetencionLiqGlobal_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionLiqGlobal_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqGlobal_PRO> ConsultarRetencionLiqGlobal_PRO(Expression<Func<RetencionLiqGlobal_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionLiqGlobal_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de RetencionLiqGlobal_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqGlobal_PRO> ConsultarRetencionLiqGlobal_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionLiqGlobal_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de Localidad_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<Localidad_PAR> ConsultarContainsLocalidad_PAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<Localidad_PAR, bool>> expresionFiltrado = ObtenerExpresionContains<Localidad_PAR>(filtro);
    			return ConsultarLocalidad_PAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Localidad_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Localidad_PAR> ConsultarEqualsLocalidad_PAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<Localidad_PAR, bool>> expresionFiltrado = ObtenerExpresionEquals<Localidad_PAR>(filtro);
    				return ConsultarLocalidad_PAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Localidad_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Localidad_PAR> ConsultarLocalidad_PAR(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<Localidad_PAR, bool>> expresionFiltrado = ObtenerFiltro<Localidad_PAR>(filtros,where);
    				return ConsultarLocalidad_PAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Localidad_PAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Localidad_PAR> ConsultarLocalidad_PAR(Expression<Func<Localidad_PAR, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<Localidad_PAR>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de Localidad_PAR que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Localidad_PAR> ConsultarLocalidad_PAR(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<Localidad_PAR>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de Retencion_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<Retencion_TAR> ConsultarContainsRetencion_TAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<Retencion_TAR, bool>> expresionFiltrado = ObtenerExpresionContains<Retencion_TAR>(filtro);
    			return ConsultarRetencion_TAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Retencion_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Retencion_TAR> ConsultarEqualsRetencion_TAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<Retencion_TAR, bool>> expresionFiltrado = ObtenerExpresionEquals<Retencion_TAR>(filtro);
    				return ConsultarRetencion_TAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Retencion_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Retencion_TAR> ConsultarRetencion_TAR(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<Retencion_TAR, bool>> expresionFiltrado = ObtenerFiltro<Retencion_TAR>(filtros,where);
    				return ConsultarRetencion_TAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Retencion_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Retencion_TAR> ConsultarRetencion_TAR(Expression<Func<Retencion_TAR, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<Retencion_TAR>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de Retencion_TAR que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Retencion_TAR> ConsultarRetencion_TAR(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<Retencion_TAR>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de CargaNovedadesProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<CargaNovedadesProduccion_PRO> ConsultarContainsCargaNovedadesProduccion_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<CargaNovedadesProduccion_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<CargaNovedadesProduccion_PRO>(filtro);
    			return ConsultarCargaNovedadesProduccion_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de CargaNovedadesProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CargaNovedadesProduccion_PRO> ConsultarEqualsCargaNovedadesProduccion_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<CargaNovedadesProduccion_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<CargaNovedadesProduccion_PRO>(filtro);
    				return ConsultarCargaNovedadesProduccion_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de CargaNovedadesProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CargaNovedadesProduccion_PRO> ConsultarCargaNovedadesProduccion_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<CargaNovedadesProduccion_PRO, bool>> expresionFiltrado = ObtenerFiltro<CargaNovedadesProduccion_PRO>(filtros,where);
    				return ConsultarCargaNovedadesProduccion_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de CargaNovedadesProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CargaNovedadesProduccion_PRO> ConsultarCargaNovedadesProduccion_PRO(Expression<Func<CargaNovedadesProduccion_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<CargaNovedadesProduccion_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de CargaNovedadesProduccion_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CargaNovedadesProduccion_PRO> ConsultarCargaNovedadesProduccion_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<CargaNovedadesProduccion_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de CentroServicios_PUA que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<CentroServicios_PUA> ConsultarContainsCentroServicios_PUA(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<CentroServicios_PUA, bool>> expresionFiltrado = ObtenerExpresionContains<CentroServicios_PUA>(filtro);
    			return ConsultarCentroServicios_PUA(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de CentroServicios_PUA que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CentroServicios_PUA> ConsultarEqualsCentroServicios_PUA(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<CentroServicios_PUA, bool>> expresionFiltrado = ObtenerExpresionEquals<CentroServicios_PUA>(filtro);
    				return ConsultarCentroServicios_PUA(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de CentroServicios_PUA que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CentroServicios_PUA> ConsultarCentroServicios_PUA(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<CentroServicios_PUA, bool>> expresionFiltrado = ObtenerFiltro<CentroServicios_PUA>(filtros,where);
    				return ConsultarCentroServicios_PUA(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de CentroServicios_PUA que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CentroServicios_PUA> ConsultarCentroServicios_PUA(Expression<Func<CentroServicios_PUA, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<CentroServicios_PUA>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de CentroServicios_PUA que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<CentroServicios_PUA> ConsultarCentroServicios_PUA(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<CentroServicios_PUA>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de Servicio_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<Servicio_TAR> ConsultarContainsServicio_TAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<Servicio_TAR, bool>> expresionFiltrado = ObtenerExpresionContains<Servicio_TAR>(filtro);
    			return ConsultarServicio_TAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Servicio_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Servicio_TAR> ConsultarEqualsServicio_TAR(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<Servicio_TAR, bool>> expresionFiltrado = ObtenerExpresionEquals<Servicio_TAR>(filtro);
    				return ConsultarServicio_TAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Servicio_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Servicio_TAR> ConsultarServicio_TAR(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<Servicio_TAR, bool>> expresionFiltrado = ObtenerFiltro<Servicio_TAR>(filtros,where);
    				return ConsultarServicio_TAR(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de Servicio_TAR que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Servicio_TAR> ConsultarServicio_TAR(Expression<Func<Servicio_TAR, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<Servicio_TAR>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de Servicio_TAR que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<Servicio_TAR> ConsultarServicio_TAR(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<Servicio_TAR>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de NovedadCentroServicio_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<NovedadCentroServicio_PRO> ConsultarContainsNovedadCentroServicio_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<NovedadCentroServicio_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<NovedadCentroServicio_PRO>(filtro);
    			return ConsultarNovedadCentroServicio_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de NovedadCentroServicio_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<NovedadCentroServicio_PRO> ConsultarEqualsNovedadCentroServicio_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<NovedadCentroServicio_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<NovedadCentroServicio_PRO>(filtro);
    				return ConsultarNovedadCentroServicio_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de NovedadCentroServicio_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<NovedadCentroServicio_PRO> ConsultarNovedadCentroServicio_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<NovedadCentroServicio_PRO, bool>> expresionFiltrado = ObtenerFiltro<NovedadCentroServicio_PRO>(filtros,where);
    				return ConsultarNovedadCentroServicio_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de NovedadCentroServicio_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<NovedadCentroServicio_PRO> ConsultarNovedadCentroServicio_PRO(Expression<Func<NovedadCentroServicio_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<NovedadCentroServicio_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de NovedadCentroServicio_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<NovedadCentroServicio_PRO> ConsultarNovedadCentroServicio_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<NovedadCentroServicio_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de RetencionConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<RetencionConcepto_PRO> ConsultarContainsRetencionConcepto_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<RetencionConcepto_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<RetencionConcepto_PRO>(filtro);
    			return ConsultarRetencionConcepto_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionConcepto_PRO> ConsultarEqualsRetencionConcepto_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionConcepto_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<RetencionConcepto_PRO>(filtro);
    				return ConsultarRetencionConcepto_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionConcepto_PRO> ConsultarRetencionConcepto_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionConcepto_PRO, bool>> expresionFiltrado = ObtenerFiltro<RetencionConcepto_PRO>(filtros,where);
    				return ConsultarRetencionConcepto_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionConcepto_PRO> ConsultarRetencionConcepto_PRO(Expression<Func<RetencionConcepto_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionConcepto_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de RetencionConcepto_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionConcepto_PRO> ConsultarRetencionConcepto_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionConcepto_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de RetencionXCiudadConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<RetencionXCiudadConcepto_PRO> ConsultarContainsRetencionXCiudadConcepto_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<RetencionXCiudadConcepto_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<RetencionXCiudadConcepto_PRO>(filtro);
    			return ConsultarRetencionXCiudadConcepto_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionXCiudadConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionXCiudadConcepto_PRO> ConsultarEqualsRetencionXCiudadConcepto_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionXCiudadConcepto_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<RetencionXCiudadConcepto_PRO>(filtro);
    				return ConsultarRetencionXCiudadConcepto_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionXCiudadConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionXCiudadConcepto_PRO> ConsultarRetencionXCiudadConcepto_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionXCiudadConcepto_PRO, bool>> expresionFiltrado = ObtenerFiltro<RetencionXCiudadConcepto_PRO>(filtros,where);
    				return ConsultarRetencionXCiudadConcepto_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionXCiudadConcepto_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionXCiudadConcepto_PRO> ConsultarRetencionXCiudadConcepto_PRO(Expression<Func<RetencionXCiudadConcepto_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionXCiudadConcepto_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de RetencionXCiudadConcepto_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionXCiudadConcepto_PRO> ConsultarRetencionXCiudadConcepto_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionXCiudadConcepto_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de LiquidacionProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<LiquidacionProduccion_PRO> ConsultarContainsLiquidacionProduccion_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<LiquidacionProduccion_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<LiquidacionProduccion_PRO>(filtro);
    			return ConsultarLiquidacionProduccion_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de LiquidacionProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<LiquidacionProduccion_PRO> ConsultarEqualsLiquidacionProduccion_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<LiquidacionProduccion_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<LiquidacionProduccion_PRO>(filtro);
    				return ConsultarLiquidacionProduccion_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de LiquidacionProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<LiquidacionProduccion_PRO> ConsultarLiquidacionProduccion_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<LiquidacionProduccion_PRO, bool>> expresionFiltrado = ObtenerFiltro<LiquidacionProduccion_PRO>(filtros,where);
    				return ConsultarLiquidacionProduccion_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de LiquidacionProduccion_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<LiquidacionProduccion_PRO> ConsultarLiquidacionProduccion_PRO(Expression<Func<LiquidacionProduccion_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<LiquidacionProduccion_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de LiquidacionProduccion_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<LiquidacionProduccion_PRO> ConsultarLiquidacionProduccion_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<LiquidacionProduccion_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    		/// <summary>
    		/// Retorna la lista de RetencionLiqXCiudad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    			public IEnumerable<RetencionLiqXCiudad_PRO> ConsultarContainsRetencionLiqXCiudad_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			Expression<Func<RetencionLiqXCiudad_PRO, bool>> expresionFiltrado = ObtenerExpresionContains<RetencionLiqXCiudad_PRO>(filtro);
    			return ConsultarRetencionLiqXCiudad_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionLiqXCiudad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqXCiudad_PRO> ConsultarEqualsRetencionLiqXCiudad_PRO(IDictionary<string, string> filtro, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionLiqXCiudad_PRO, bool>> expresionFiltrado = ObtenerExpresionEquals<RetencionLiqXCiudad_PRO>(filtro);
    				return ConsultarRetencionLiqXCiudad_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionLiqXCiudad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="filtro">Diccionario a través del cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqXCiudad_PRO> ConsultarRetencionLiqXCiudad_PRO(IDictionary<string, string> filtros, Dictionary<LambdaExpression, OperadorLogico> where, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    				Expression<Func<RetencionLiqXCiudad_PRO, bool>> expresionFiltrado = ObtenerFiltro<RetencionLiqXCiudad_PRO>(filtros,where);
    				return ConsultarRetencionLiqXCiudad_PRO(expresionFiltrado, campoOrdenamiento, out totalRegistros, indicePagina, registrosPorPagina, esAscendente);
    		}
    
    		/// <summary>
    		/// Retorna la lista de RetencionLiqXCiudad_PRO que cumpla con las expresiones de filtrado y ordenamiento
          /// </summary>
    		/// <param name="expresionFiltrado">Expresión por la cual se filtra la lista</param>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de de registros que satisfacen la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqXCiudad_PRO> ConsultarRetencionLiqXCiudad_PRO(Expression<Func<RetencionLiqXCiudad_PRO, bool>> expresionFiltrado, string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Número de Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query			
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionLiqXCiudad_PRO>();
    
    				   totalRegistros = objectSet.Where(expresionFiltrado).Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
    													  .Where(expresionFiltrado)										
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" ASC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList()
        											 :
        									objectSet.OrdenarUsandoExpresion(campoOrdenamiento+" DESC")
        													.Where(expresionFiltrado)										
        													.Skip(indicePagina * registrosPorPagina)
        													.Take(registrosPorPagina)
        													.ToList();
    			}	
    		}
    
    		/// <summary>
          /// Retorna la lista de RetencionLiqXCiudad_PRO que cumpla con la expresión de ordenamiento
          /// </summary>
        	/// <param name="campoOrdenamiento">Campo por el cual se va a realizar el ordenamiento</param>
    		/// <param name="totalRegistros">Retorna el total de registros que genera la consulta sin paginar</param>
        	/// <param name="indicePagina">Índice de página a retornar</param>
        	/// <param name="registrosPorPagina">Registros por página</param>
        	/// <param name="esAscendente">Indica si es ascendente el ordenamiento</param>
        	/// <returns></returns>
    		public IEnumerable<RetencionLiqXCiudad_PRO> ConsultarRetencionLiqXCiudad_PRO(string campoOrdenamiento, out int totalRegistros, int indicePagina = 0, int registrosPorPagina = 20, bool esAscendente = true)
    		{
    			// Verificando parámetros para la consulta
    			if (indicePagina < 0)
    				throw new ArgumentException("Página inválida");
    
    			if (registrosPorPagina <= 0)
    				throw new ArgumentException("Número de registros por página no válido");
    
    			//Create associated IObjectSet and perform query
    			var objectSet = ((IObjectContextAdapter)this).ObjectContext.CreateObjectSet<RetencionLiqXCiudad_PRO>();
    		
    		   totalRegistros = objectSet.Count();
             
    			if (campoOrdenamiento.Trim() == string.Empty)
             {
                string llavePrimaria = objectSet.EntitySet.ElementType.KeyMembers.First().Name;
                return objectSet.OrdenarPor(llavePrimaria)
                                             .Skip(indicePagina * registrosPorPagina)
                                             .Take(registrosPorPagina).ToList();
             }
    			else
    			{
    				return (esAscendente) ? objectSet.OrdenarPor(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList()
    											 :
    									objectSet.OrdenarPorDescendente(campoOrdenamiento)
    													.Skip(indicePagina * registrosPorPagina)
    													.Take(registrosPorPagina)
    													.ToList();
    			}
    		}
    	
        #endregion
    
    		#region Propiedades
        public DbSet<MotivoNovedad_PRO> MotivoNovedad_PRO { get; set; }
        public DbSet<RetencionLiqGlobal_PRO> RetencionLiqGlobal_PRO { get; set; }
        public DbSet<Localidad_PAR> Localidad_PAR { get; set; }
        public DbSet<Retencion_TAR> Retencion_TAR { get; set; }
        public DbSet<CargaNovedadesProduccion_PRO> CargaNovedadesProduccion_PRO { get; set; }
        public DbSet<CentroServicios_PUA> CentroServicios_PUA { get; set; }
        public DbSet<Servicio_TAR> Servicio_TAR { get; set; }
        public DbSet<NovedadCentroServicio_PRO> NovedadCentroServicio_PRO { get; set; }
        public DbSet<RetencionConcepto_PRO> RetencionConcepto_PRO { get; set; }
        public DbSet<RetencionXCiudadConcepto_PRO> RetencionXCiudadConcepto_PRO { get; set; }
        public DbSet<LiquidacionProduccion_PRO> LiquidacionProduccion_PRO { get; set; }
        public DbSet<RetencionLiqXCiudad_PRO> RetencionLiqXCiudad_PRO { get; set; }
    
        public virtual ObjectResult<PRObtenerNovedadTipoNoved> paObtenerNovedadTipoNoved_PRO(Nullable<long> idCentroServicios, Nullable<System.DateTime> fechaCorte, Nullable<int> idTipoNovedad)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRObtenerNovedadTipoNoved).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var fechaCorteParameter = fechaCorte.HasValue ?
                new ObjectParameter("fechaCorte", fechaCorte) :
                new ObjectParameter("fechaCorte", typeof(System.DateTime));
    
            var idTipoNovedadParameter = idTipoNovedad.HasValue ?
                new ObjectParameter("idTipoNovedad", idTipoNovedad) :
                new ObjectParameter("idTipoNovedad", typeof(int));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRObtenerNovedadTipoNoved>("paObtenerNovedadTipoNoved_PRO", idCentroServiciosParameter, fechaCorteParameter, idTipoNovedadParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerUltLiquidacionCentroSvc> paObtenerUltLiquidacionCentroSvc_PRO(Nullable<long> idCentroServicios)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerUltLiquidacionCentroSvc).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerUltLiquidacionCentroSvc>("paObtenerUltLiquidacionCentroSvc_PRO", idCentroServiciosParameter);
        }
    
        public virtual int paActualizaEstLiquidacion_PRO(Nullable<long> idLiquidacion, string estadoLiquidacion)
        {
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var estadoLiquidacionParameter = estadoLiquidacion != null ?
                new ObjectParameter("estadoLiquidacion", estadoLiquidacion) :
                new ObjectParameter("estadoLiquidacion", typeof(string));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paActualizaEstLiquidacion_PRO", idLiquidacionParameter, estadoLiquidacionParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidacionNovedad> paObtenerLiquidacionNovedad_PRO(Nullable<long> idLiquidacion, Nullable<int> idTipoNovedad)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidacionNovedad).Assembly);
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var idTipoNovedadParameter = idTipoNovedad.HasValue ?
                new ObjectParameter("idTipoNovedad", idTipoNovedad) :
                new ObjectParameter("idTipoNovedad", typeof(int));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidacionNovedad>("paObtenerLiquidacionNovedad_PRO", idLiquidacionParameter, idTipoNovedadParameter);
        }
    
        public virtual int paCrearLiquidaIngresosFijos_PRO(Nullable<long> idLiquidacion, Nullable<long> idCentroServicios, Nullable<short> idTipoComisionFija, string descripcionTipoComi, Nullable<decimal> valorConfigurado, Nullable<decimal> valorLiquidado, Nullable<int> idContrato, Nullable<int> diasHabiles, Nullable<System.DateTime> fechaGrabacion, string creadoPor)
        {
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var idTipoComisionFijaParameter = idTipoComisionFija.HasValue ?
                new ObjectParameter("idTipoComisionFija", idTipoComisionFija) :
                new ObjectParameter("idTipoComisionFija", typeof(short));
    
            var descripcionTipoComiParameter = descripcionTipoComi != null ?
                new ObjectParameter("descripcionTipoComi", descripcionTipoComi) :
                new ObjectParameter("descripcionTipoComi", typeof(string));
    
            var valorConfiguradoParameter = valorConfigurado.HasValue ?
                new ObjectParameter("valorConfigurado", valorConfigurado) :
                new ObjectParameter("valorConfigurado", typeof(decimal));
    
            var valorLiquidadoParameter = valorLiquidado.HasValue ?
                new ObjectParameter("valorLiquidado", valorLiquidado) :
                new ObjectParameter("valorLiquidado", typeof(decimal));
    
            var idContratoParameter = idContrato.HasValue ?
                new ObjectParameter("idContrato", idContrato) :
                new ObjectParameter("idContrato", typeof(int));
    
            var diasHabilesParameter = diasHabiles.HasValue ?
                new ObjectParameter("diasHabiles", diasHabiles) :
                new ObjectParameter("diasHabiles", typeof(int));
    
            var fechaGrabacionParameter = fechaGrabacion.HasValue ?
                new ObjectParameter("fechaGrabacion", fechaGrabacion) :
                new ObjectParameter("fechaGrabacion", typeof(System.DateTime));
    
            var creadoPorParameter = creadoPor != null ?
                new ObjectParameter("creadoPor", creadoPor) :
                new ObjectParameter("creadoPor", typeof(string));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paCrearLiquidaIngresosFijos_PRO", idLiquidacionParameter, idCentroServiciosParameter, idTipoComisionFijaParameter, descripcionTipoComiParameter, valorConfiguradoParameter, valorLiquidadoParameter, idContratoParameter, diasHabilesParameter, fechaGrabacionParameter, creadoPorParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaIngresosFijos> paObtenerLiquidaIngresosFijos_PRO(Nullable<long> idLiquidacion)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaIngresosFijos).Assembly);
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaIngresosFijos>("paObtenerLiquidaIngresosFijos_PRO", idLiquidacionParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaProduccion> paObtenerLiquidaProduccion_PRO(Nullable<long> idRacol, Nullable<long> idCentroServicios, Nullable<long> idLiquidacion, Nullable<System.DateTime> fechaLiquidacion, Nullable<bool> incluyeFecha, Nullable<int> pageIndex, Nullable<int> pageSize)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaProduccion).Assembly);
    
            var idRacolParameter = idRacol.HasValue ?
                new ObjectParameter("idRacol", idRacol) :
                new ObjectParameter("idRacol", typeof(long));
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var fechaLiquidacionParameter = fechaLiquidacion.HasValue ?
                new ObjectParameter("fechaLiquidacion", fechaLiquidacion) :
                new ObjectParameter("fechaLiquidacion", typeof(System.DateTime));
    
            var incluyeFechaParameter = incluyeFecha.HasValue ?
                new ObjectParameter("incluyeFecha", incluyeFecha) :
                new ObjectParameter("incluyeFecha", typeof(bool));
    
            var pageIndexParameter = pageIndex.HasValue ?
                new ObjectParameter("PageIndex", pageIndex) :
                new ObjectParameter("PageIndex", typeof(int));
    
            var pageSizeParameter = pageSize.HasValue ?
                new ObjectParameter("PageSize", pageSize) :
                new ObjectParameter("PageSize", typeof(int));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaProduccion>("paObtenerLiquidaProduccion_PRO", idRacolParameter, idCentroServiciosParameter, idLiquidacionParameter, fechaLiquidacionParameter, incluyeFechaParameter, pageIndexParameter, pageSizeParameter);
        }
    
        public virtual int paActualizaLiquidaAprobada_PRO(Nullable<long> idLiquidacion, Nullable<long> numeroGuiaInterna, Nullable<short> numGiro, Nullable<System.DateTime> fechaGrabacion, string aprobadoPor)
        {
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var numeroGuiaInternaParameter = numeroGuiaInterna.HasValue ?
                new ObjectParameter("numeroGuiaInterna", numeroGuiaInterna) :
                new ObjectParameter("numeroGuiaInterna", typeof(long));
    
            var numGiroParameter = numGiro.HasValue ?
                new ObjectParameter("numGiro", numGiro) :
                new ObjectParameter("numGiro", typeof(short));
    
            var fechaGrabacionParameter = fechaGrabacion.HasValue ?
                new ObjectParameter("fechaGrabacion", fechaGrabacion) :
                new ObjectParameter("fechaGrabacion", typeof(System.DateTime));
    
            var aprobadoPorParameter = aprobadoPor != null ?
                new ObjectParameter("aprobadoPor", aprobadoPor) :
                new ObjectParameter("aprobadoPor", typeof(string));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paActualizaLiquidaAprobada_PRO", idLiquidacionParameter, numeroGuiaInternaParameter, numGiroParameter, fechaGrabacionParameter, aprobadoPorParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerCenSvcSinPrograLiqui> paObtenerCenSvcSinPrograLiqui_PRO(Nullable<long> idCentroServicios, Nullable<long> idRacol)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerCenSvcSinPrograLiqui).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var idRacolParameter = idRacol.HasValue ?
                new ObjectParameter("idRacol", idRacol) :
                new ObjectParameter("idRacol", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerCenSvcSinPrograLiqui>("paObtenerCenSvcSinPrograLiqui_PRO", idCentroServiciosParameter, idRacolParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerRetencionNovedad> paObtenerRetencionNovedad_PRO(Nullable<long> idCentroServicios, Nullable<System.DateTime> fechaCorte, Nullable<int> idTipoMotivoNovedad)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerRetencionNovedad).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var fechaCorteParameter = fechaCorte.HasValue ?
                new ObjectParameter("fechaCorte", fechaCorte) :
                new ObjectParameter("fechaCorte", typeof(System.DateTime));
    
            var idTipoMotivoNovedadParameter = idTipoMotivoNovedad.HasValue ?
                new ObjectParameter("idTipoMotivoNovedad", idTipoMotivoNovedad) :
                new ObjectParameter("idTipoMotivoNovedad", typeof(int));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerRetencionNovedad>("paObtenerRetencionNovedad_PRO", idCentroServiciosParameter, fechaCorteParameter, idTipoMotivoNovedadParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaRetenNovedad> paObtenerLiquidaRetenNovedad_PRO(Nullable<long> idLiquidacion, Nullable<int> idTipoMotivoNovedad)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaRetenNovedad).Assembly);
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var idTipoMotivoNovedadParameter = idTipoMotivoNovedad.HasValue ?
                new ObjectParameter("idTipoMotivoNovedad", idTipoMotivoNovedad) :
                new ObjectParameter("idTipoMotivoNovedad", typeof(int));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaRetenNovedad>("paObtenerLiquidaRetenNovedad_PRO", idLiquidacionParameter, idTipoMotivoNovedadParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerComisionConcepto> paObtenerComisionConcepto_PRO(Nullable<long> idCentroServicios, Nullable<System.DateTime> fechaCorte)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerComisionConcepto).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var fechaCorteParameter = fechaCorte.HasValue ?
                new ObjectParameter("fechaCorte", fechaCorte) :
                new ObjectParameter("fechaCorte", typeof(System.DateTime));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerComisionConcepto>("paObtenerComisionConcepto_PRO", idCentroServiciosParameter, fechaCorteParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerComisionPuntosAcargo> paObtenerComisionPuntosAcargo_PRO(Nullable<long> idCentroServicios, Nullable<System.DateTime> fechaCorte)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerComisionPuntosAcargo).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var fechaCorteParameter = fechaCorte.HasValue ?
                new ObjectParameter("fechaCorte", fechaCorte) :
                new ObjectParameter("fechaCorte", typeof(System.DateTime));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerComisionPuntosAcargo>("paObtenerComisionPuntosAcargo_PRO", idCentroServiciosParameter, fechaCorteParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaComiConcepto> paObtenerLiquidaComiConcepto_PRO(Nullable<long> idLiquidacion)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaComiConcepto).Assembly);
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaComiConcepto>("paObtenerLiquidaComiConcepto_PRO", idLiquidacionParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerRetencionServicio> paObtenerRetencionServicio_PRO(Nullable<long> idCentroServicios, Nullable<System.DateTime> fechaCorte)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerRetencionServicio).Assembly);
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var fechaCorteParameter = fechaCorte.HasValue ?
                new ObjectParameter("fechaCorte", fechaCorte) :
                new ObjectParameter("fechaCorte", typeof(System.DateTime));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerRetencionServicio>("paObtenerRetencionServicio_PRO", idCentroServiciosParameter, fechaCorteParameter);
        }
    
        public virtual ObjectResult<Nullable<long>> paCrearLiquidacionProducci_PRO(Nullable<decimal> totalComisionVenta, Nullable<long> idCentroServicios, Nullable<decimal> totalComisionPuntos, Nullable<decimal> totalIngresosFijos, Nullable<decimal> totalNovedadReintegro, Nullable<decimal> totalNovedadDescuento, Nullable<decimal> totalRetencionConcepto, Nullable<decimal> totalRetencionReintegro, Nullable<System.DateTime> fechaInicioCorte, Nullable<System.DateTime> fechaFinCorte, Nullable<decimal> saldoCaja, Nullable<decimal> totalPagos, Nullable<decimal> totalDeducciones, Nullable<System.DateTime> fechaGrabacion, Nullable<System.DateTime> fechaAprobacion, string creadoPor, string usuarioAprueba)
        {
            var totalComisionVentaParameter = totalComisionVenta.HasValue ?
                new ObjectParameter("totalComisionVenta", totalComisionVenta) :
                new ObjectParameter("totalComisionVenta", typeof(decimal));
    
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var totalComisionPuntosParameter = totalComisionPuntos.HasValue ?
                new ObjectParameter("totalComisionPuntos", totalComisionPuntos) :
                new ObjectParameter("totalComisionPuntos", typeof(decimal));
    
            var totalIngresosFijosParameter = totalIngresosFijos.HasValue ?
                new ObjectParameter("totalIngresosFijos", totalIngresosFijos) :
                new ObjectParameter("totalIngresosFijos", typeof(decimal));
    
            var totalNovedadReintegroParameter = totalNovedadReintegro.HasValue ?
                new ObjectParameter("totalNovedadReintegro", totalNovedadReintegro) :
                new ObjectParameter("totalNovedadReintegro", typeof(decimal));
    
            var totalNovedadDescuentoParameter = totalNovedadDescuento.HasValue ?
                new ObjectParameter("totalNovedadDescuento", totalNovedadDescuento) :
                new ObjectParameter("totalNovedadDescuento", typeof(decimal));
    
            var totalRetencionConceptoParameter = totalRetencionConcepto.HasValue ?
                new ObjectParameter("totalRetencionConcepto", totalRetencionConcepto) :
                new ObjectParameter("totalRetencionConcepto", typeof(decimal));
    
            var totalRetencionReintegroParameter = totalRetencionReintegro.HasValue ?
                new ObjectParameter("totalRetencionReintegro", totalRetencionReintegro) :
                new ObjectParameter("totalRetencionReintegro", typeof(decimal));
    
            var fechaInicioCorteParameter = fechaInicioCorte.HasValue ?
                new ObjectParameter("fechaInicioCorte", fechaInicioCorte) :
                new ObjectParameter("fechaInicioCorte", typeof(System.DateTime));
    
            var fechaFinCorteParameter = fechaFinCorte.HasValue ?
                new ObjectParameter("fechaFinCorte", fechaFinCorte) :
                new ObjectParameter("fechaFinCorte", typeof(System.DateTime));
    
            var saldoCajaParameter = saldoCaja.HasValue ?
                new ObjectParameter("saldoCaja", saldoCaja) :
                new ObjectParameter("saldoCaja", typeof(decimal));
    
            var totalPagosParameter = totalPagos.HasValue ?
                new ObjectParameter("totalPagos", totalPagos) :
                new ObjectParameter("totalPagos", typeof(decimal));
    
            var totalDeduccionesParameter = totalDeducciones.HasValue ?
                new ObjectParameter("totalDeducciones", totalDeducciones) :
                new ObjectParameter("totalDeducciones", typeof(decimal));
    
            var fechaGrabacionParameter = fechaGrabacion.HasValue ?
                new ObjectParameter("fechaGrabacion", fechaGrabacion) :
                new ObjectParameter("fechaGrabacion", typeof(System.DateTime));
    
            var fechaAprobacionParameter = fechaAprobacion.HasValue ?
                new ObjectParameter("fechaAprobacion", fechaAprobacion) :
                new ObjectParameter("fechaAprobacion", typeof(System.DateTime));
    
            var creadoPorParameter = creadoPor != null ?
                new ObjectParameter("creadoPor", creadoPor) :
                new ObjectParameter("creadoPor", typeof(string));
    
            var usuarioApruebaParameter = usuarioAprueba != null ?
                new ObjectParameter("usuarioAprueba", usuarioAprueba) :
                new ObjectParameter("usuarioAprueba", typeof(string));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<Nullable<long>>("paCrearLiquidacionProducci_PRO", totalComisionVentaParameter, idCentroServiciosParameter, totalComisionPuntosParameter, totalIngresosFijosParameter, totalNovedadReintegroParameter, totalNovedadDescuentoParameter, totalRetencionConceptoParameter, totalRetencionReintegroParameter, fechaInicioCorteParameter, fechaFinCorteParameter, saldoCajaParameter, totalPagosParameter, totalDeduccionesParameter, fechaGrabacionParameter, fechaAprobacionParameter, creadoPorParameter, usuarioApruebaParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaRetenConce> paObtenerLiquidaRetenConce_PRO(Nullable<long> idLiquidacion)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaRetenConce).Assembly);
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaRetenConce>("paObtenerLiquidaRetenConce_PRO", idLiquidacionParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaComiPtoAcargo> paObtenerLiquidaComiPtoAcargo_PRO(Nullable<long> idLiquidacion)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaComiPtoAcargo).Assembly);
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaComiPtoAcargo>("paObtenerLiquidaComiPtoAcargo_PRO", idLiquidacionParameter);
        }
    
        public virtual int paCrearLiquidacionesAgrupadas_PRO(Nullable<long> idCentroServicios, Nullable<System.DateTime> fechaCorte, Nullable<long> idLiquidacion, string creadoPor)
        {
            var idCentroServiciosParameter = idCentroServicios.HasValue ?
                new ObjectParameter("idCentroServicios", idCentroServicios) :
                new ObjectParameter("idCentroServicios", typeof(long));
    
            var fechaCorteParameter = fechaCorte.HasValue ?
                new ObjectParameter("fechaCorte", fechaCorte) :
                new ObjectParameter("fechaCorte", typeof(System.DateTime));
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var creadoPorParameter = creadoPor != null ?
                new ObjectParameter("creadoPor", creadoPor) :
                new ObjectParameter("creadoPor", typeof(string));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paCrearLiquidacionesAgrupadas_PRO", idCentroServiciosParameter, fechaCorteParameter, idLiquidacionParameter, creadoPorParameter);
        }
    
        public virtual ObjectResult<PRpaObtenerLiquidaProduAprobadas> paObtenerLiquidaProduAprobadas_PRO(Nullable<long> idCentroLogistico, Nullable<long> idLiquidacion, string idTipoCentroSvc, Nullable<long> idProgramacion)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(PRpaObtenerLiquidaProduAprobadas).Assembly);
    
            var idCentroLogisticoParameter = idCentroLogistico.HasValue ?
                new ObjectParameter("idCentroLogistico", idCentroLogistico) :
                new ObjectParameter("idCentroLogistico", typeof(long));
    
            var idLiquidacionParameter = idLiquidacion.HasValue ?
                new ObjectParameter("idLiquidacion", idLiquidacion) :
                new ObjectParameter("idLiquidacion", typeof(long));
    
            var idTipoCentroSvcParameter = idTipoCentroSvc != null ?
                new ObjectParameter("idTipoCentroSvc", idTipoCentroSvc) :
                new ObjectParameter("idTipoCentroSvc", typeof(string));
    
            var idProgramacionParameter = idProgramacion.HasValue ?
                new ObjectParameter("idProgramacion", idProgramacion) :
                new ObjectParameter("idProgramacion", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<PRpaObtenerLiquidaProduAprobadas>("paObtenerLiquidaProduAprobadas_PRO", idCentroLogisticoParameter, idLiquidacionParameter, idTipoCentroSvcParameter, idProgramacionParameter);
        }
    
        public virtual int paLiquidacionProduccion_PRO(Nullable<int> mes, Nullable<int> ano, Nullable<long> idCentroServicio, string usuario)
        {
            var mesParameter = mes.HasValue ?
                new ObjectParameter("mes", mes) :
                new ObjectParameter("mes", typeof(int));
    
            var anoParameter = ano.HasValue ?
                new ObjectParameter("ano", ano) :
                new ObjectParameter("ano", typeof(int));
    
            var idCentroServicioParameter = idCentroServicio.HasValue ?
                new ObjectParameter("IdCentroServicio", idCentroServicio) :
                new ObjectParameter("IdCentroServicio", typeof(long));
    
            var usuarioParameter = usuario != null ?
                new ObjectParameter("Usuario", usuario) :
                new ObjectParameter("Usuario", typeof(string));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paLiquidacionProduccion_PRO", mesParameter, anoParameter, idCentroServicioParameter, usuarioParameter);
        }
    
        public virtual int paAprobarLiquidaciones_PRO(Nullable<int> mes, Nullable<int> ano, Nullable<long> idRacol, string idCiudad, Nullable<long> idCS, Nullable<long> idLiqDesde, Nullable<long> idLiqHasta)
        {
            var mesParameter = mes.HasValue ?
                new ObjectParameter("Mes", mes) :
                new ObjectParameter("Mes", typeof(int));
    
            var anoParameter = ano.HasValue ?
                new ObjectParameter("Ano", ano) :
                new ObjectParameter("Ano", typeof(int));
    
            var idRacolParameter = idRacol.HasValue ?
                new ObjectParameter("IdRacol", idRacol) :
                new ObjectParameter("IdRacol", typeof(long));
    
            var idCiudadParameter = idCiudad != null ?
                new ObjectParameter("IdCiudad", idCiudad) :
                new ObjectParameter("IdCiudad", typeof(string));
    
            var idCSParameter = idCS.HasValue ?
                new ObjectParameter("IdCS", idCS) :
                new ObjectParameter("IdCS", typeof(long));
    
            var idLiqDesdeParameter = idLiqDesde.HasValue ?
                new ObjectParameter("IdLiqDesde", idLiqDesde) :
                new ObjectParameter("IdLiqDesde", typeof(long));
    
            var idLiqHastaParameter = idLiqHasta.HasValue ?
                new ObjectParameter("IdLiqHasta", idLiqHasta) :
                new ObjectParameter("IdLiqHasta", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paAprobarLiquidaciones_PRO", mesParameter, anoParameter, idRacolParameter, idCiudadParameter, idCSParameter, idLiqDesdeParameter, idLiqHastaParameter);
        }
    
        public virtual int paEliminarLiqProduccion_PRO(Nullable<long> idLiqProduccion)
        {
            var idLiqProduccionParameter = idLiqProduccion.HasValue ?
                new ObjectParameter("IdLiqProduccion", idLiqProduccion) :
                new ObjectParameter("IdLiqProduccion", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paEliminarLiqProduccion_PRO", idLiqProduccionParameter);
        }
    
        public virtual int paCargarLiquidacionCaja_PRO(Nullable<int> mes, Nullable<int> ano)
        {
            var mesParameter = mes.HasValue ?
                new ObjectParameter("mes", mes) :
                new ObjectParameter("mes", typeof(int));
    
            var anoParameter = ano.HasValue ?
                new ObjectParameter("ano", ano) :
                new ObjectParameter("ano", typeof(int));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction("paCargarLiquidacionCaja_PRO", mesParameter, anoParameter);
        }
    
        public virtual ObjectResult<paConsultarLiquidaciones_PRO_Result> paConsultarLiquidaciones_PRO(Nullable<int> mes, Nullable<int> ano, Nullable<long> idRacol, string idCiudad, Nullable<long> idCS, Nullable<long> idLiqDesde, Nullable<long> idLiqHasta)
        {
            ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(paConsultarLiquidaciones_PRO_Result).Assembly);
    
            var mesParameter = mes.HasValue ?
                new ObjectParameter("Mes", mes) :
                new ObjectParameter("Mes", typeof(int));
    
            var anoParameter = ano.HasValue ?
                new ObjectParameter("Ano", ano) :
                new ObjectParameter("Ano", typeof(int));
    
            var idRacolParameter = idRacol.HasValue ?
                new ObjectParameter("IdRacol", idRacol) :
                new ObjectParameter("IdRacol", typeof(long));
    
            var idCiudadParameter = idCiudad != null ?
                new ObjectParameter("IdCiudad", idCiudad) :
                new ObjectParameter("IdCiudad", typeof(string));
    
            var idCSParameter = idCS.HasValue ?
                new ObjectParameter("IdCS", idCS) :
                new ObjectParameter("IdCS", typeof(long));
    
            var idLiqDesdeParameter = idLiqDesde.HasValue ?
                new ObjectParameter("IdLiqDesde", idLiqDesde) :
                new ObjectParameter("IdLiqDesde", typeof(long));
    
            var idLiqHastaParameter = idLiqHasta.HasValue ?
                new ObjectParameter("IdLiqHasta", idLiqHasta) :
                new ObjectParameter("IdLiqHasta", typeof(long));
    
            return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<paConsultarLiquidaciones_PRO_Result>("paConsultarLiquidaciones_PRO", mesParameter, anoParameter, idRacolParameter, idCiudadParameter, idCSParameter, idLiqDesdeParameter, idLiqHastaParameter);
        }
    	#endregion
    }
		/// <summary>
    /// Operadores de comparación en una sentencia where
    /// </summary>
    public enum OperadorComparacion
    {
        Equal,
        NotEqual,
        Contains,
        Between
    }

    /// <summary>
    /// Operadores lógicos en una sentencia where
    /// </summary>
    public enum OperadorLogico
    {
        Or,
        And
    }    

		  public class ParameterRebinder : ExpressionVisitor
  {
    private readonly Dictionary<ParameterExpression, ParameterExpression> map;

    public ParameterRebinder(Dictionary<ParameterExpression, ParameterExpression> map)
    {
      this.map = map ?? new Dictionary<ParameterExpression, ParameterExpression>();
    }

    public static Expression ReplaceParameters(Dictionary<ParameterExpression, ParameterExpression> map, Expression exp)
    {
      return new ParameterRebinder(map).Visit(exp);
    }

    protected override Expression VisitParameter(ParameterExpression p)
    {
      ParameterExpression replacement;
      if (map.TryGetValue(p, out replacement))
      {
        p = replacement;
      }
      return base.VisitParameter(p);
    }
  }

  public static class Utility
  {
    public static Expression<T> Compose<T>(this Expression<T> first, Expression<T> second, Func<Expression, Expression, Expression> merge)
    {
      // build parameter map (from parameters of second to parameters of first)
      var map = first.Parameters.Select((f, i) => new { f, s = second.Parameters[i] }).ToDictionary(p => p.s, p => p.f);

      // replace parameters in the second lambda expression with parameters from the first
      var secondBody = ParameterRebinder.ReplaceParameters(map, second.Body);

      // apply composition of lambda expression bodies to parameters from the first expression
      return Expression.Lambda<T>(merge(first.Body, secondBody), first.Parameters);
    }

    public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> first, Expression<Func<T, bool>> second)
    {
      return first.Compose(second, Expression.And);
    }

    public static Expression<Func<T, bool>> Or<T>(this Expression<Func<T, bool>> first, Expression<Func<T, bool>> second)
    {
      return first.Compose(second, Expression.Or);
    }
  }

	  public static class AuditExtensions
    {
      /// <summary>
      /// Adds Auditing to an ObjectContext for the specified <paramref name="fromType"/>.
      /// </summary>
      /// <typeparam name="fromType">The source entity type (including derivatives) to audit changes to.</typeparam>
      /// <typeparam name="toType">The target entity type that audit records will be stored in.</typeparam>
      /// <param name="context">The ObjectContext for which Auditing should be enabled.</param>
      /// <param name="mapping">A lambda expression that maps the changed <paramref name="fromType"/> entity to a <paramref name="toType"/> audit record.</param>
      /// <param name="addToContext">A lambda expression that adds the audit entity to an entity collection.</param>
      public static void Audit<fromType, toType>(
          this DbContext context,
          Func<IDataRecord, EntityState, toType> mapping,
          Action<toType> addToContext)
      {
        IObjectContextAdapter oc = context as IObjectContextAdapter;
        oc.ObjectContext.SavingChanges +=
            new EventHandler((o, e) =>
                CreateAuditRecord<fromType, toType>(context, mapping, addToContext));
      }

      /// <summary>
      /// Helper function that is called during ObjectContext.SavingChanges, and is responsible for managing the
      /// process of mapping all changed entities to an audit entity, and adding them to an entity collection.
      /// </summary>
      /// <remarks>
      /// Note that at present this function will be called once for every entity type that is being audited. If
      /// you don't like this it should be easy to optimize it.
      /// </remarks>
      /// <typeparam name="fromType">The source entity type (including derivatives) to audit changes to.</typeparam>
      /// <typeparam name="toType">The target entity type that audit records will be stored in.</typeparam>
      /// <param name="context">The ObjectContext for which Auditing should be enabled.</param>
      /// <param name="mapping">A lambda expression that maps the changed <paramref name="fromType"/> entity to a <paramref name="toType"/> audit record.</param>
      /// <param name="addToContext">A lambda expression that adds the audit entity to an entity collection.</param>
      private static void CreateAuditRecord<fromType, toType>(
          DbContext context,
          Func<IDataRecord, EntityState, toType> mapping,
          Action<toType> addToContext)
      {
        IObjectContextAdapter oc = context as IObjectContextAdapter;
        oc.ObjectContext.DetectChanges();
        // get a list of changes to audit
        IEnumerable<ObjectStateEntry> entities =
            from e in oc.ObjectContext.ObjectStateManager.GetObjectStateEntries(
                EntityState.Modified | EntityState.Deleted)
            where
                e.IsRelationship == false &&
                typeof(fromType).IsAssignableFrom(e.Entity.GetType())
            select e;

        foreach (ObjectStateEntry item in entities)
        {
          // map the changed item to an audit record entry
          toType auditRecord = mapping(item.OriginalValues, item.State);
          // and add it to the object context so that it is persisted for us
          addToContext(auditRecord);
        }
      }

      /// <summary>
      /// Retrieves a fields value from an IDataRecord (including a DbDataRecord) in a strongly typed,
      /// compile-time checked fashion. This overload assumes the IDataRecord represents an EntityObject
      /// for which a property's value should be retrieved.
      /// </summary>
      /// <typeparam name="E">The Entity type the IDataRecord represents</typeparam>
      /// <typeparam name="T">The data type of the field</typeparam>
      /// <param name="record">The IDataRecord that contains the data</param>
      /// <param name="propertySelector">An expression that identifies the entity member to retrieve</param>
      /// <returns>The field's value.</returns>
      /// <example>
      /// <code>
      /// IDataRecord record = GetRecord();
      /// string name = record.Field&lt;Person, string>(person => person.Name);
      /// int age = record.Field&lt;Person, int>(person => person.Age);
      /// DateTime createdDate = record.Field&lt;Person, DateTime>(person => person.CreatedDate);
      /// </code>
      /// </example>
      public static T Field<E, T>(this IDataRecord record, System.Linq.Expressions.Expression<Func<E, T>> propertySelector)
      {
        System.Linq.Expressions.MemberExpression memberExpression = propertySelector.Body as System.Linq.Expressions.MemberExpression;
        System.Reflection.MemberInfo propertyInfo = memberExpression.Member;

        int fieldIndex = record.GetOrdinal(propertyInfo.Name);
        return Field<T>(record, fieldIndex);
      }

      /// <summary>
      /// Retrieves a fields value from an IDataRecord in a strongly typed fashion.
      /// </summary>
      /// <remarks>
      /// This code is based on similar functionality in the EFExtensions project; see
      /// http://code.msdn.microsoft.com/EFExtensions
      /// </remarks>
      /// <typeparam name="T">The data type of the field.</typeparam>
      /// <param name="record">The IDataRecord that contains the data</param>
      /// <param name="ordinal">The field's index in the IDataRecord</param>
      /// <returns>The field's value.</returns>
      public static T Field<T>(this IDataRecord record, int ordinal)
      {
        object value = record.IsDBNull(ordinal) ? null : record.GetValue(ordinal);
        return (T)value;
      }
    }

		/// <summary>
   /// Extensión para ordenamiento por nombre del campo
   /// </summary>
   public static class OrderExtension
   {
		/// <sumary>
		/// Ordena usando una expresión de ordenamiento, por ejemplo:
		///		iqueryable.OrdenarUsandoExpresion("Employee.LastName, Freight DESC")
		/// </sumary>
      public static IOrderedQueryable<TEntity> OrdenarUsandoExpresion<TEntity>(this IQueryable<TEntity> source, string sortExpression) where TEntity : class
      {
             String[] orderFields = sortExpression.Split(',');
             IOrderedQueryable<TEntity> result = null;
              bool sortDescending=false;
              if (sortExpression.Contains(" DESC"))
              {
                  sortDescending = true;
              }
             for (int currentFieldIndex = 0; currentFieldIndex < orderFields.Length; currentFieldIndex++)
             {
                String[] expressionPart = orderFields[currentFieldIndex].Trim().Split(' ');
                String sortField = expressionPart[0];
                //Boolean sortDescending = (expressionPart.Length == 2) && (expressionPart[1].Equals("DESC", StringComparison.OrdinalIgnoreCase));
                if (sortDescending)
                {
                   result = currentFieldIndex == 0 ? source.OrdenarPorDescendente(sortField) : result.EntoncesPorDescendente(sortField);
                }
                else
                {
                   result = currentFieldIndex == 0 ? source.OrdenarPor(sortField) : result.EntoncesPor(sortField);
                }
             }
             return result;
      }

      public static IOrderedQueryable<TEntity> OrdenarPor<TEntity>(this IQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "OrderBy", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      public static IOrderedQueryable<TEntity> OrdenarPorDescendente<TEntity>(this IQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "OrderByDescending", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      public static IOrderedQueryable<TEntity> EntoncesPor<TEntity>(this IOrderedQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "ThenBy", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      public static IOrderedQueryable<TEntity> EntoncesPorDescendente<TEntity>(this IOrderedQueryable<TEntity> source, string fieldName) where TEntity : class
      {
         MethodCallExpression resultExp = GenerateMethodCall<TEntity>(source, "ThenByDescending", fieldName);
         return source.Provider.CreateQuery<TEntity>(resultExp) as IOrderedQueryable<TEntity>;
      }

      private static MethodCallExpression GenerateMethodCall<TEntity>(IQueryable<TEntity> source, string methodName, String fieldName) where TEntity : class
      {
         Type type = typeof(TEntity);
         Type selectorResultType;
         LambdaExpression selector = GenerateSelector<TEntity>(fieldName, out selectorResultType);
         MethodCallExpression resultExp = Expression.Call(typeof(Queryable), methodName,
                         new Type[] { type, selectorResultType },
                         source.Expression, Expression.Quote(selector));
         return resultExp;
      }

      private static LambdaExpression GenerateSelector<TEntity>(String propertyName, out Type resultType) where TEntity : class
      {
         // Create a parameter to pass into the Lambda expression (Entity => Entity.OrderByField).
         var parameter = Expression.Parameter(typeof(TEntity), "Entity");
         //  create the selector part, but support child properties
         PropertyInfo property;
         Expression propertyAccess;
         if (propertyName.Contains('.'))
         {
            // support to be sorted on child fields.
            String[] childProperties = propertyName.Split('.');
            property = typeof(TEntity).GetProperty(childProperties[0], BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            propertyAccess = Expression.MakeMemberAccess(parameter, property);
            for (int i = 1; i < childProperties.Length; i++)
            {
               property = property.PropertyType.GetProperty(childProperties[i], BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
               propertyAccess = Expression.MakeMemberAccess(propertyAccess, property);
            }
         }
         else
         {
            property = typeof(TEntity).GetProperty(propertyName, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            propertyAccess = Expression.MakeMemberAccess(parameter, property);
         }
         resultType = property.PropertyType;
         // Create the order by expression.
         return Expression.Lambda(propertyAccess, parameter);
      }
   }
}

